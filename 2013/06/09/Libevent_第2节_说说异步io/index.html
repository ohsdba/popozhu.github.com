<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    

    <title>Libevent印象，说说异步IO | popozhu</title>

    

    <!-- css -->
    <link href="http://fonts.useso.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/css/style.css">

    </head>

    <body>
	<div class="container">
	    <div class="banner">
    <div>
        <span class="site-title"> <a href="/" id="logo">popozhu</a> </span>

        
    </div>

    <div class="banner-right">
        <span class="banner-item"> <a href="/archives"> Misc </a> </span>
        <span class="banner-item"> <a href="/about"> About </a> </span>
    </div>
</div>


	    <section id="main"><article class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
	<header class="article-header">
	    <div class="article-title">
		<div class="title">Libevent印象，说说异步IO</div> 
		<small>
		    <time datetime="2013-06-09T15:43:22.000Z" itemprop="datePublished">June 9 2013</time>
		</small>
	    </div>
	</header>
    

    <div class="article-entry" itemprop="articleBody">
	
	    
	    
		<div class="article-toc"> Toc <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#example-a-simple-blocking-http-client"><span class="toc-text">Example: A simple blocking HTTP client</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bad-example"><span class="toc-text">Bad Example</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#example-forking-rot13-server"><span class="toc-text">Example: Forking ROT13 server</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bad-example-busy-polling-all-sockets"><span class="toc-text">Bad Example: busy-polling all sockets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#example-using-select"><span class="toc-text">Example: Using select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#example-select-based-rot13-server"><span class="toc-text">Example: select()-based ROT13 server</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#example-a-low-level-rot13-server-with-libevent"><span class="toc-text">Example: A low-level ROT13 server with Libevent</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用libevent方便吗在windows下又如何"><span class="toc-text">使用Libevent方便吗，在Windows下又如何</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#example-a-simpler-rot13-server-with-libevent"><span class="toc-text">Example: A simpler ROT13 server with Libevent</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#真的有这么高效率"><span class="toc-text">真的有这么高效率？</span></a> </div>
	    

	    <blockquote>
<p>&#x539F;&#x6587;&#xFF1A;<a href="http://www.wangafu.net/~nickm/libevent-book/01_intro.html" target="_blank" rel="external">Chapter 1: A tiny introduction to asynchronous IO.</a></p>
</blockquote>
<p>&#x5F88;&#x591A;&#x4EBA;&#x5F00;&#x59CB;&#x65F6;&#x4F7F;&#x7528;&#x7684;&#x662F;&#x963B;&#x585E;&#x5F0F;IO&#x51FD;&#x6570;&#x3002;<br>&#x5982;&#x679C;&#x4E00;&#x4E2A;&#x51FD;&#x6570;&#x5728;&#x64CD;&#x4F5C;&#x5B8C;&#x6210;&#x4E4B;&#x524D;&#xFF0C;&#x6216;&#x8005;&#x5728;&#x8D85;&#x65F6;&#x4E4B;&#x524D;&#xFF0C;&#x90FD;&#x4E0D;&#x4F1A;&#x8FD4;&#x56DE;&#xFF0C;&#x90A3;&#x4E48;&#x5C31;&#x8BF4;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x662F;<strong>&#x540C;&#x6B65;</strong>&#x7684;&#x3002;<br>&#x6BD4;&#x5982;&#x5F53;&#x4F60;&#x5BF9;&#x4E00;&#x4E2A;TCP&#x8FDE;&#x63A5;&#x8C03;&#x7528;<code>connect()</code>&#xFF0C;&#x4F60;&#x7684;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x4F1A;&#x6709;&#x4E00;&#x4E2A;&#x961F;&#x5217;&#xFF0C;&#x4E00;&#x4E2A;&#x4FDD;&#x5B58;&#x53D1;&#x9001;&#x51FA;&#x53BB;&#x7684;<strong>SYN&#x8BF7;&#x6C42;</strong>&#x7684;&#x961F;&#x5217;&#x3002;<br>&#x7136;&#x540E;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E2A;<strong>SYN&#x8BF7;&#x6C42;</strong>&#xFF0C;&#x7CFB;&#x7EDF;&#x5C1D;&#x8BD5;&#x7B49;&#x5F85;TCP&#x53E6;&#x4E00;&#x7AEF;&#x8FD4;&#x56DE;&#x5BF9;&#x5E94;&#x7684;&#x786E;&#x8BA4;&#x7801;&#xFF0C;&#x5373;<strong>SYN ACK</strong>&#x3002;<br>&#x5728;&#x786E;&#x8BA4;&#x7801;ACK&#x8FD4;&#x56DE;&#x4E4B;&#x524D;&#xFF0C;&#x6216;&#x8005;&#x76F4;&#x5230;&#x8D85;&#x65F6;&#xFF0C;&#x540C;&#x6B65;&#x7684;&#x51FD;&#x6570;&#x662F;&#x4E0D;&#x4F1A;&#x8FD4;&#x56DE;&#xFF0C;&#x79F0;&#x4E4B;&#x4E3A;&#x963B;&#x585E;IO&#x3002;  </p>
<p>&#x4E0B;&#x9762;&#x6709;&#x4E2A;&#x4F7F;&#x7528;&#x963B;&#x585E;IO&#x51FD;&#x6570;&#x7684;&#x4F8B;&#x5B50;&#xFF0C;&#x5B83;&#x6253;&#x5F00;&#x4E00;&#x4E2A;&#x8FDE;&#x63A5;&#xFF0C;&#x8FDE;&#x63A5;&#x5230;www.google.com&#xFF0C;&#x53D1;&#x9001;&#x4E00;&#x4E2A;&#x7B80;&#x5355;&#x7684;HTTP&#x8BF7;&#x6C42;&#xFF0C;&#x7136;&#x540E;&#x6253;&#x5370;&#x51FA;&#x8FD4;&#x56DE;&#x5185;&#x5BB9;&#x5230;stdout&#x3002;  </p>
<h4 id="example-a-simple-blocking-http-client"><a href="#Example-A-simple-blocking-HTTP-client" class="headerlink" title="Example: A simple blocking HTTP client"></a>Example: A simple blocking HTTP client</h4><pre><code>/* For sockaddr_in */
#include &lt;netinet/in.h&gt;
/* For socket functions */
#include &lt;sys/socket.h&gt;
/* For gethostbyname */
#include &lt;netdb.h&gt;

#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int c, char **v)
{
    const char query[] =
        &quot;GET / HTTP/1.0\r\n&quot;
        &quot;Host: www.google.com\r\n&quot;
        &quot;\r\n&quot;;
    const char hostname[] = &quot;www.google.com&quot;;
    struct sockaddr_in sin;
    struct hostent *h;
    const char *cp;
    int fd;
    ssize_t n_written, remaining;
    char buf[1024];

    /* Look up the IP address for the hostname.  
       Watch out; 
       this isn&apos;t threadsafe on most platforms. */  
    h = gethostbyname(hostname);
    if (!h) {
        fprintf(stderr, &quot;Couldn&apos;t lookup %s: %s&quot;, hostname, hstrerror(h_errno));
        return 1;
    }
    if (h-&gt;h_addrtype != AF_INET) {
        fprintf(stderr, &quot;No ipv6 support, sorry.&quot;);
        return 1;
    }

    /* Allocate a new socket */
    fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd &lt; 0) {
        perror(&quot;socket&quot;);
        return 1;
    }

    /* Connect to the remote host. */
    sin.sin_family = AF_INET;
    sin.sin_port = htons(80);
    sin.sin_addr = *(struct in_addr*)h-&gt;h_addr;
    if (connect(fd, (struct sockaddr*) &amp;sin, sizeof(sin))) {
        perror(&quot;connect&quot;);
        close(fd);
        return 1;
    }

    /* Write the query. */
    /* XXX Can send succeed partially? */
    cp = query;
    remaining = strlen(query);
    while (remaining) {
      n_written = send(fd, cp, remaining, 0);
      if (n_written &lt;= 0) {
        perror(&quot;send&quot;);
        return 1;
      }
      remaining -= n_written;
      cp += n_written;
    }

    /* Get an answer back. */
    while (1) {
        ssize_t result = recv(fd, buf, sizeof(buf), 0);
        if (result == 0) {
            break;
        } else if (result &lt; 0) {
            perror(&quot;recv&quot;);
            close(fd);
            return 1;
        }
        fwrite(buf, 1, result, stdout);
    }

    close(fd);
    return 0;
}
</code></pre><p>&#x4E0A;&#x9762;&#x4F7F;&#x7528;&#x7684;&#x7F51;&#x7EDC;&#x76F8;&#x5173;&#x51FD;&#x6570;&#x90FD;&#x662F;&#x963B;&#x585E;&#x5F0F;&#x7684;&#x3002;  </p>
<ol>
<li><code>gethostbyname</code>&#x5728;&#x6210;&#x529F;&#x89E3;&#x6790;&#x57DF;&#x540D;<code>www.google.com</code>&#x6216;&#x8D85;&#x65F6;&#x524D;&#x662F;&#x4E0D;&#x4F1A;&#x8FD4;&#x56DE;&#x7684;&#xFF1B;  </li>
<li><code>connect</code>&#x5728;&#x6210;&#x529F;&#x8FDE;&#x63A5;&#x540E;&#x624D;&#x8FD4;&#x56DE;&#xFF1B;  </li>
<li><code>recv</code>&#x63A5;&#x6536;&#x6570;&#x636E;&#x624D;&#x8FD4;&#x56DE;&#xFF0C;&#x6216;&#x8005;&#x5BF9;&#x65B9;&#x5173;&#x95ED;&#x4E86;sock&#x4E5F;&#x4F1A;&#x8BA9;recv&#x8FD4;&#x56DE;&#xFF1B;  </li>
<li>&#x800C;<code>send</code>&#x4E5F;&#x963B;&#x585E;&#xFF0C;&#x76F4;&#x5230;&#x628A;&#x6570;&#x636E;&#x590D;&#x5236;&#x5230;&#x7CFB;&#x7EDF;&#x5185;&#x6838;buffer&#x4E4B;&#x4E2D;&#x3002;  </li>
</ol>
<p>&#x5982;&#x679C;&#x4F60;&#x5728;&#x540C;&#x4E00;&#x65F6;&#x95F4;&#x5185;&#x53EA;&#x505A;&#x4E00;&#x4E2A;&#x4E8B;&#x60C5;&#xFF0C;IO&#x963B;&#x585E;&#x51FD;&#x6570;&#x4E5F;&#x6CA1;&#x6709;&#x4EC0;&#x4E48;&#x4E0D;&#x597D;&#x3002;&#x4F46;&#x5047;&#x82E5;&#x4F60;&#x7684;&#x7A0B;&#x5E8F;&#x91CC;&#x8981;&#x540C;&#x65F6;&#x54CD;&#x5E94;&#x591A;&#x4E2A;&#x8FDE;&#x63A5;&#xFF0C;&#x6BD4;&#x5982;&#x4F60;&#x9700;&#x8981;&#x540C;&#x65F6;&#x4ECE;2&#x4E2A;&#x8FDE;&#x63A5;sock&#x4E2D;&#x63A5;&#x6536;&#x6570;&#x636E;&#xFF0C;&#x800C;&#x4E14;&#x4F60;&#x4E0D;&#x77E5;&#x9053;&#x54EA;&#x4E2A;&#x6570;&#x636E;&#x5148;&#x5230;&#x6765;&#xFF0C;&#x4F60;&#x4E0D;&#x80FD;&#x8FD9;&#x6837;&#x5199;&#x4F60;&#x7684;&#x7A0B;&#x5E8F;:  </p>
<h4 id="bad-example"><a href="#Bad-Example" class="headerlink" title="Bad Example"></a>Bad Example</h4><pre><code>/* This won&apos;t work. */
char buf[1024];
int i, n;
while (i_still_want_to_read()) {
    for (i=0; i&lt;n_sockets; ++i) {
        n = recv(fd[i], buf, sizeof(buf), 0);
        if (n==0)
            handle_close(fd[i]);
        else if (n&lt;0)
            handle_error(fd[i], errno);
        else
            handle_input(fd[i], buf, n);
    }
}
</code></pre><p>&#x56E0;&#x4E3A;&#x5982;&#x679C;<code>fd[2]</code>&#x7684;&#x6570;&#x636E;&#x5148;&#x5230;&#x6765;&#x7684;&#x8BDD;&#xFF0C;&#x8FD9;&#x6BB5;&#x4EE3;&#x7801;&#x751A;&#x81F3;&#x4E0D;&#x4F1A;&#x5C1D;&#x8BD5;&#x53BB;&#x8BFB;&#x53D6;<code>fd[1]</code>&#x7684;&#x6570;&#x636E;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x8981;&#x6C42;&#x6570;&#x636E;&#x662F;&#x6309;&#x987A;&#x5E8F;&#x5230;&#x6765;&#xFF0C;&#x800C;&#x8FD9;&#x660E;&#x663E;&#x662F;&#x7B80;&#x5355;&#x5730;&#x60F3;&#x5F53;&#x7136;&#x4E86;&#x3002;  </p>
<p>&#x5F53;&#x7136;&#x4E5F;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x591A;&#x4E2A;<strong>&#x8FDB;&#x7A0B;/&#x7EBF;&#x7A0B;</strong>&#x6765;&#x5904;&#x7406;&#x6BCF;&#x4E2A;sock&#xFF0C;&#x6BCF;&#x4E2A;sock&#x7684;&#x6570;&#x636E;&#x5904;&#x7406;&#x4E92;&#x4E0D;&#x5F71;&#x54CD;&#xFF0C;A&#x8FDB;&#x7A0B;&#x963B;&#x585E;&#x4E86;&#xFF0C;&#x5E76;&#x4E0D;&#x5F71;&#x54CD;&#x5230;B&#x8FDB;&#x7A0B;&#x7684;&#x5DE5;&#x4F5C;&#x3002;<br>&#x4E3E;&#x4F8B;&#xFF0C;&#x4E0B;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x662F;&#x6211;&#x4EEC;&#x7684;<strong>ROT13</strong>&#x670D;&#x52A1;&#x7AEF;&#x4EE3;&#x7801;&#xFF0C;&#x4F7F;&#x7528;unix&#x7684;<code>fork()</code>&#x4E3A;&#x6BCF;&#x4E2A;&#x8FDE;&#x63A5;&#x5EFA;&#x7ACB;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;&#x3002;&#x4ECE;&#x7AEF;&#x53E3;40713&#x4E2D;&#x6BCF;&#x6B21;&#x8BFB;&#x53D6;&#x4E00;&#x884C;&#xFF0C;&#x5BF9;&#x8BFB;&#x53D6;&#x7684;&#x8BE5;&#x884C;&#x6BCF;&#x4E2A;&#x5B57;&#x7B26;&#x505A;&#x70B9;&#x8F6C;&#x6362;&#xFF0C;&#x7136;&#x540E;&#x628A;&#x8BE5;&#x884C;&#x6570;&#x636E;&#x5199;&#x56DE;&#x3002;  </p>
<h4 id="example-forking-rot13-server"><a href="#Example-Forking-ROT13-server" class="headerlink" title="Example: Forking ROT13 server"></a>Example: Forking ROT13 server</h4><pre><code>/* For sockaddr_in */
#include &lt;netinet/in.h&gt;
/* For socket functions */
#include &lt;sys/socket.h&gt;

#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_LINE 16384

char
rot13_char(char c)
{
    /* We don&apos;t want to use isalpha here; setting the locale would change
     * which characters are considered alphabetical. */
    if ((c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;m&apos;) || (c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;M&apos;))
        return c + 13;
    else if ((c &gt;= &apos;n&apos; &amp;&amp; c &lt;= &apos;z&apos;) || (c &gt;= &apos;N&apos; &amp;&amp; c &lt;= &apos;Z&apos;))
        return c - 13;
    else
        return c;
}

void
child(int fd)
{
    char outbuf[MAX_LINE+1];
    size_t outbuf_used = 0;
    ssize_t result;

    while (1) {
        char ch;
        result = recv(fd, &amp;ch, 1, 0);
        if (result == 0) {
            break;
        } else if (result == -1) {
            perror(&quot;read&quot;);
            break;
        }

        /* We do this test to keep the user from overflowing the buffer. */
        if (outbuf_used &lt; sizeof(outbuf)) {
            outbuf[outbuf_used++] = rot13_char(ch);
        }

        if (ch == &apos;\n&apos;) {
            send(fd, outbuf, outbuf_used, 0);
            outbuf_used = 0;
            continue;
        }
    }
}

void
run(void)
{
    int listener;
    struct sockaddr_in sin;

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(40713);

    listener = socket(AF_INET, SOCK_STREAM, 0);

#ifndef WIN32
    {
        int one = 1;
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, sizeof(one));
    }
#endif

    if (bind(listener, (struct sockaddr*)&amp;sin, sizeof(sin)) &lt; 0) {
        perror(&quot;bind&quot;);
        return;
    }

    if (listen(listener, 16)&lt;0) {
        perror(&quot;listen&quot;);
        return;
    }



    while (1) {
        struct sockaddr_storage ss;
        socklen_t slen = sizeof(ss);
        int fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);
        if (fd &lt; 0) {
            perror(&quot;accept&quot;);
        } else {
            if (fork() == 0) {
                child(fd);
                exit(0);
            }
        }
    }
}

int
main(int c, char **v)
{
    run();
    return 0;
}
</code></pre><p>&#x90A3;&#x4E48;&#xFF0C;&#x6709;&#x6CA1;&#x6709;&#x66F4;&#x597D;&#x7684;&#x65B9;&#x6848;&#x6765;&#x540C;&#x65F6;&#x5904;&#x7406;&#x591A;&#x4E2A;&#x8FDE;&#x63A5;&#x5417;&#xFF1F;&#x6211;&#x5C31;&#x8FD9;&#x6837;&#x4F7F;&#x7528;&#x4E0A;&#x9762;&#x7684;&#x65B9;&#x6848;&#x56DE;&#x53BB;&#x89E3;&#x51B3;&#x6211;&#x7684;&#x95EE;&#x9898;&#x4E86;&#x5417;&#xFF1F;<br>&#x5F53;&#x7136;&#x4E0D;&#x662F;&#xFF01;<br>&#x9996;&#x5148;&#xFF0C;&#x5728;&#x4E00;&#x4E9B;&#x5E73;&#x53F0;&#x4E0A;&#xFF0C;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;/&#x7EBF;&#x7A0B;&#x7684;&#x4EE3;&#x4EF7;&#x662F;&#x5F88;&#x6602;&#x8D35;&#x7684;&#x3002;&#x5B9E;&#x9645;&#x5F00;&#x53D1;&#x4E2D;&#x4F60;&#x4F1A;&#x4F7F;&#x7528;&#x4E00;&#x4E2A;&#x7EBF;&#x7A0B;&#x6C60;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x8FDB;&#x7A0B;&#x3002; &#x4E0D;&#x8FC7;&#xFF0C;&#x5047;&#x82E5;&#x4F60;&#x9700;&#x8981;&#x5904;&#x7406;&#x6570;&#x4EE5;&#x5343;&#x4E07;&#x4E2A;&#x8FDE;&#x63A5;&#xFF0C;&#x7EF4;&#x62A4;&#x8FD9;&#x4E48;&#x591A;&#x7EBF;&#x7A0B;&#xFF0C;&#x6027;&#x80FD;&#x4E5F;&#x8BB8;&#x6CA1;&#x6709;&#x4F60;&#x671F;&#x5F85;&#x7684;&#x90A3;&#x4E48;&#x7F8E;&#x597D;&#x3002;  </p>
<p>&#x4F7F;&#x7528;&#x7EBF;&#x7A0B;&#x4E0D;&#x662F;&#x6700;&#x597D;&#x7684;&#x7B54;&#x6848;&#x3002;&#x5728;Unix&#x4E0B;&#xFF0C;&#x4F60;&#x53EF;&#x4EE5;&#x8BBE;&#x7F6E;sock&#x4E3A;&#x975E;&#x963B;&#x585E;&#xFF0C;&#x4F7F;&#x7528;&#x51FD;&#x6570;<code>fcntl</code>&#xFF1A;  </p>
<pre><code>fcntl(fd, F_SETFL, O_NONBLOCK); 
//fd&#x5BF9;&#x5E94;&#x4E8E;sock&#x7684;&#x6587;&#x4EF6;&#x63CF;&#x8FF0;&#x7B26;(file descriptor)

//&#x5176;&#x5B9E;&#x4E00;&#x822C;&#x5148;&#x83B7;&#x53D6;sock&#x7684;flag&#xFF0C;&#x4FEE;&#x6539;flag&#xFF0C;&#x518D;&#x8BBE;&#x7F6E;&#x65B0;&#x7684;flag&#xFF0C;&#x5982;&#x4E0B;&#x5927;&#x6982;  
/* Set a socket as nonblocking */
int flags; 
if ((flags = fcntl (fd, F_GETFL, 0)) &lt; 0) 
     err_sys(&quot;F_GETFL error&quot;); 
flags |= O_NONBLOCK;
if (fcntl(fd, F_SETFL, flags) &lt; 0) 
     err_sys(&quot;F_SETFL error&quot;);
</code></pre><p>&#x4E00;&#x65E6;&#x4F60;&#x5BF9;sock fd&#x8BBE;&#x7F6E;&#x975E;&#x963B;&#x585E;&#xFF0C;&#x90A3;&#x4E48;&#x5BF9;&#x8FD9;&#x4E2A;fd&#x8C03;&#x7528;&#x7F51;&#x7EDC;&#x76F8;&#x5173;&#x7684;&#x51FD;&#x6570;&#xFF0C;&#x6BD4;&#x5982;recv&#xFF0C;&#x51FD;&#x6570;&#x4F1A;&#x9A6C;&#x4E0A;&#x8FD4;&#x56DE;&#xFF0C;&#x8FD9;&#x65F6;&#x4F60;&#x8981;&#x68C0;&#x67E5;&#x8FD4;&#x56DE;&#x7801;&#x4EE5;&#x53CA;&#x5168;&#x5C40;&#x53D8;&#x91CF;<code>errno</code>&#xFF0C;&#x4E0A;&#x9762;&#x4ECE;&#x591A;&#x4E2A;sock&#x8BFB;&#x53D6;&#x6570;&#x636E;&#x7684;&#x4EE3;&#x7801;&#x6BB5;&#x4FEE;&#x6539;&#x4E3A;&#xFF1A;   </p>
<h4 id="bad-example-busy-polling-all-sockets"><a href="#Bad-Example-busy-polling-all-sockets" class="headerlink" title="Bad Example: busy-polling all sockets"></a>Bad Example: busy-polling all sockets</h4><pre><code>/* This will work, but the performance will be unforgivably bad. */
int i, n;
char buf[1024];
for (i=0; i &lt; n_sockets; ++i)
    fcntl(fd[i], F_SETFL, O_NONBLOCK);

while (i_still_want_to_read()) {
    for (i=0; i &lt; n_sockets; ++i) {
        n = recv(fd[i], buf, sizeof(buf), 0);
        if (n == 0) {
            handle_close(fd[i]);
        } else if (n &lt; 0) {
            if (errno == EAGAIN)
                 ; /* The kernel didn&apos;t have any data for us to read. */
            else
                 handle_error(fd[i], errno);
         } else {
            handle_input(fd[i], buf, n);
         }
    }
}
</code></pre><p>&#x4E0A;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x4E5F;&#x5B58;&#x5728;&#x6027;&#x80FD;&#x95EE;&#x9898;&#xFF0C;2&#x4E2A;&#x539F;&#x56E0;&#xFF1A;  </p>
<ol>
<li>&#x5982;&#x679C;&#x6CA1;&#x6709;&#x6570;&#x636E;&#x5230;&#x6765;&#xFF0C;&#x4EE3;&#x7801;&#x4E0D;&#x65AD;&#x5FAA;&#x73AF;&#xFF0C;&#x4E0D;&#x65AD;&#x6D88;&#x8017;cpu&#xFF1B;  </li>
<li>&#x6BCF;&#x6B21;&#x8F6E;&#x8BE2;&#x90FD;&#x4F1A;&#x8C03;&#x7528;&#x5185;&#x6838;&#x7EA7;&#x522B;&#x7684;&#x51FD;&#x6570;&#xFF08;&#x5373;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#xFF09;&#xFF0C;&#x56E0;&#x4E3A;&#x6709;&#x6CA1;&#x6709;&#x6570;&#x636E;&#x53EF;&#x4EE5;&#x8BFB;&#x53D6;&#xFF0C;&#x4E00;&#x822C;&#x662F;&#x68C0;&#x67E5;&#x5185;&#x6838;&#x6570;&#x636E;buffer&#xFF0C;&#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;&#x7531;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x5E2E;&#x6211;&#x4EEC;&#x505A;&#x68C0;&#x67E5;&#x3002;&#x6211;&#x4EEC;&#x4E0D;&#x65AD;&#x8F6E;&#x8BE2;&#xFF0C;&#x6BCF;&#x6B21;&#x4EA7;&#x751F;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x7684;&#x6D88;&#x8017;&#xFF0C; &#x4E0D;&#x662F;&#x5F88;&#x73AF;&#x4FDD;&#x7684;&#x505A;&#x6CD5;&#x3002;</li>
</ol>
<p>&#x6211;&#x4EEC;&#x9700;&#x8981;&#x66F4;&#x4E3A;&#x667A;&#x80FD;&#x7684;&#x65B9;&#x5F0F;&#xFF0C;&#x5F53;&#x6570;&#x636E;&#x6700;&#x540E;&#x53EF;&#x8BFB;&#x65F6;&#x8BA9;&#x5185;&#x6838;&#x4E3B;&#x52A8;&#x544A;&#x8BC9;&#x6211;&#x4EEC;&#x3002;&#x6700;&#x53E4;&#x8001;&#x7684;&#x65B9;&#x5F0F;&#x662F;&#x4F7F;&#x7528;<code>select()</code>&#x3002;<br>&#x51FD;&#x6570;&#x539F;&#x578B;&#xFF1A;</p>
<pre><code>int select(int nfds, 
    fd_set *restrict readfds, 
    fd_set *restrict writefds,
     fd_set *restrict errorfds, 
     struct timeval *restrict timeout);
</code></pre><p>select&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x4F7F;&#x7528;&#x4E86;3&#x4E2A;sock fd&#x96C6;&#x5408;&#xFF08;set of fds&#xFF09;&#xFF0C; &#x5206;&#x522B;&#x5BF9;&#x5E94;&#xFF1A;  </p>
<ol>
<li>&#x53EF;&#x8BFB;&#x7684;fd&#x96C6;&#x5408;&#xFF0C;&#x544A;&#x8BC9;select()&#x8BF7;&#x68C0;&#x67E5;&#x8FD9;&#x4E2A;&#x96C6;&#x5408;&#x5185;&#x7684;fd&#x4EEC;&#xFF0C;&#x82E5;&#x5176;&#x4E2D;&#x67D0;&#x4E00;&#x4E2A;&#x53EF;&#x8BFB;&#xFF0C;&#x8BF7;select&#x8FD4;&#x56DE;&#xFF0C;&#x544A;&#x8BC9;&#x6211;&#x96C6;&#x5408;&#x4E2D;&#x6709;&#x591A;&#x5C11;&#x4E2A;fd&#x6709;&#x6570;&#x636E;&#x53EF;&#x4EE5;&#x8BFB;&#x4E86;&#xFF0C;&#x4E0B;2&#x4E2A;&#x540C;&#x610F;&#x601D;&#xFF1B;  </li>
<li>&#x53EF;&#x5199;&#x7684;fd&#x96C6;&#x5408;&#xFF1B;  </li>
<li>&#x5F02;&#x5E38;&#x7684;fd&#x96C6;&#x5408;&#xFF1B;  </li>
</ol>
<h4 id="example-using-select"><a href="#Example-Using-select" class="headerlink" title="Example: Using select"></a>Example: Using select</h4><pre><code>/* If you only have a couple dozen fds, this version won&apos;t be awful */
fd_set readset;
int i, n;
char buf[1024];

while (i_still_want_to_read()) {
    int maxfd = -1;
    FD_ZERO(&amp;readset);

    /* Add all of the interesting fds to readset */
    for (i=0; i &lt; n_sockets; ++i) {
         if (fd[i]&gt;maxfd) maxfd = fd[i];
         FD_SET(fd[i], &amp;readset);
    }

    /* Wait until one or more fds are ready to read */
    select(maxfd+1, &amp;readset, NULL, NULL, NULL);

    /* Process all of the fds that are still set in readset */
    for (i=0; i &lt; n_sockets; ++i) {
        if (FD_ISSET(fd[i], &amp;readset)) {
            n = recv(fd[i], buf, sizeof(buf), 0);
            if (n == 0) {
                handle_close(fd[i]);
            } else if (n &lt; 0) {
                if (errno == EAGAIN)
                     ; /* The kernel didn&apos;t have any data for us to read. */
                else
                     handle_error(fd[i], errno);
             } else {
                handle_input(fd[i], buf, n);
             }
        }
    }
}
</code></pre><p>&#x7136;&#x540E;&#xFF0C;&#x5BF9;&#x4E8E;&#x4E0A;&#x9762;&#x5DF2;&#x7ECF;&#x63D0;&#x5230;&#x7684;<strong>ROT13</strong>&#x670D;&#x52A1;&#x7AEF;&#x4EE3;&#x7801;(&#x4E5F;&#x8BB8;&#x4F60;&#x5DF2;&#x7ECF;&#x5FD8;&#x4E86;)&#xFF0C;&#x4F7F;&#x7528;<code>select()</code>:  </p>
<h4 id="example-select-based-rot13-server"><a href="#Example-select-based-ROT13-server" class="headerlink" title="Example: select()-based ROT13 server"></a>Example: select()-based ROT13 server</h4><pre><code>/* For sockaddr_in */
#include &lt;netinet/in.h&gt;
/* For socket functions */
#include &lt;sys/socket.h&gt;
/* For fcntl */
#include &lt;fcntl.h&gt;
/* for select */
#include &lt;sys/select.h&gt;

#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

#define MAX_LINE 16384

char
rot13_char(char c)
{
    /* We don&apos;t want to use isalpha here; setting the locale would change
     * which characters are considered alphabetical. */
    if ((c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;m&apos;) || (c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;M&apos;))
        return c + 13;
    else if ((c &gt;= &apos;n&apos; &amp;&amp; c &lt;= &apos;z&apos;) || (c &gt;= &apos;N&apos; &amp;&amp; c &lt;= &apos;Z&apos;))
        return c - 13;
    else
        return c;
}

struct fd_state {
    char buffer[MAX_LINE];
    size_t buffer_used;

    int writing;
    size_t n_written;
    size_t write_upto;
};

struct fd_state *
alloc_fd_state(void)
{
    struct fd_state *state = malloc(sizeof(struct fd_state));
    if (!state)
        return NULL;
    state-&gt;buffer_used = state-&gt;n_written = state-&gt;writing =
        state-&gt;write_upto = 0;
    return state;
}

void
free_fd_state(struct fd_state *state)
{
    free(state);
}

void
make_nonblocking(int fd)
{
    fcntl(fd, F_SETFL, O_NONBLOCK);
}

int
do_read(int fd, struct fd_state *state)
{
    char buf[1024];
    int i;
    ssize_t result;
    while (1) {
        result = recv(fd, buf, sizeof(buf), 0);
        if (result &lt;= 0)
            break;

        for (i=0; i &lt; result; ++i)  {
            if (state-&gt;buffer_used &lt; sizeof(state-&gt;buffer))
                state-&gt;buffer[state-&gt;buffer_used++] = rot13_char(buf[i]);
            if (buf[i] == &apos;\n&apos;) {
                state-&gt;writing = 1;
                state-&gt;write_upto = state-&gt;buffer_used;
            }
        }
    }

    if (result == 0) {
        return 1;
    } else if (result &lt; 0) {
        if (errno == EAGAIN)
            return 0;
        return -1;
    }

    return 0;
}

int
do_write(int fd, struct fd_state *state)
{
    while (state-&gt;n_written &lt; state-&gt;write_upto) {
        ssize_t result = send(fd, state-&gt;buffer + state-&gt;n_written,
                              state-&gt;write_upto - state-&gt;n_written, 0);
        if (result &lt; 0) {
            if (errno == EAGAIN)
                return 0;
            return -1;
        }
        assert(result != 0);

        state-&gt;n_written += result;
    }

    if (state-&gt;n_written == state-&gt;buffer_used)
        state-&gt;n_written = state-&gt;write_upto = state-&gt;buffer_used = 0;

    state-&gt;writing = 0;

    return 0;
}

void
run(void)
{
    int listener;
    struct fd_state *state[FD_SETSIZE];
    struct sockaddr_in sin;
    int i, maxfd;
    fd_set readset, writeset, exset;

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(40713);

    for (i = 0; i &lt; FD_SETSIZE; ++i)
        state[i] = NULL;

    listener = socket(AF_INET, SOCK_STREAM, 0);
    make_nonblocking(listener);

#ifndef WIN32
    {
        int one = 1;
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, sizeof(one));
    }
#endif

    if (bind(listener, (struct sockaddr*)&amp;sin, sizeof(sin)) &lt; 0) {
        perror(&quot;bind&quot;);
        return;
    }

    if (listen(listener, 16)&lt;0) {
        perror(&quot;listen&quot;);
        return;
    }

    FD_ZERO(&amp;readset);
    FD_ZERO(&amp;writeset);
    FD_ZERO(&amp;exset);

    while (1) {
        maxfd = listener;

        FD_ZERO(&amp;readset);
        FD_ZERO(&amp;writeset);
        FD_ZERO(&amp;exset);

        FD_SET(listener, &amp;readset);

        for (i=0; i &lt; FD_SETSIZE; ++i) {
            if (state[i]) {
                if (i &gt; maxfd)
                    maxfd = i;
                FD_SET(i, &amp;readset);
                if (state[i]-&gt;writing) {
                    FD_SET(i, &amp;writeset);
                }
            }
        }

        if (select(maxfd+1, &amp;readset, &amp;writeset, &amp;exset, NULL) &lt; 0) {
            perror(&quot;select&quot;);
            return;
        }

        if (FD_ISSET(listener, &amp;readset)) {
            struct sockaddr_storage ss;
            socklen_t slen = sizeof(ss);
            int fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);
            if (fd &lt; 0) {
                perror(&quot;accept&quot;);
            } else if (fd &gt; FD_SETSIZE) {
                close(fd);
            } else {
                make_nonblocking(fd);
                state[fd] = alloc_fd_state();
                assert(state[fd]);/*XXX*/
            }
        }

        for (i=0; i &lt; maxfd+1; ++i) {
            int r = 0;
            if (i == listener)
                continue;

            if (FD_ISSET(i, &amp;readset)) {
                r = do_read(i, state[i]);
            }
            if (r == 0 &amp;&amp; FD_ISSET(i, &amp;writeset)) {
                r = do_write(i, state[i]);
            }
            if (r) {
                free_fd_state(state[i]);
                state[i] = NULL;
                close(i);
            }
        }
    }
}

int
main(int c, char **v)
{
    setvbuf(stdout, NULL, _IONBF, 0);

    run();
    return 0;
}
</code></pre><p>&#x4F46;&#x662F;&#x6211;&#x4EEC;&#x8FD8;&#x6CA1;&#x5B8C;&#x6210;&#x3002;&#x968F;&#x7740;&#x6BCF;&#x4E2A;fd&#x96C6;&#x5408;&#x4E2D;fd&#x6570;&#x91CF;&#x7684;&#x589E;&#x591A;&#xFF0C;&#x6BCF;&#x6B21;&#x68C0;&#x67E5;&#x4E5F;&#x76F8;&#x5E94;&#x8981;&#x82B1;&#x8D39;&#x66F4;&#x591A;&#x65F6;&#x95F4;&#x3002;<br>&#x4E0D;&#x540C;&#x7684;&#x7CFB;&#x7EDF;&#x63D0;&#x4F9B;&#x4E0D;&#x540C;&#x7684;&#x4F18;&#x5316;&#x65B9;&#x6848;&#xFF0C;&#x5305;&#x62EC;poll(), epoll(), kqueue(), evports, /dev/poll&#x3002;<br>&#x6240;&#x6709;&#x8FD9;&#x4E9B;&#x4F18;&#x5316;&#x90FD;&#x80FD;&#x83B7;&#x5F97;&#x66F4;&#x597D;&#x7684;&#x6027;&#x80FD;&#xFF0C;&#x800C;&#x4E14;&#x9664;&#x4E86;poll()&#xFF0C;&#x5176;&#x4ED6;&#x7684;&#x51FD;&#x6570;&#xFF0C;&#x589E;&#x52A0;&#x3001;&#x5220;&#x9664;&#x4E00;&#x4E2A;fd&#xFF0C;&#x6216;&#x8005;&#x6D4B;&#x8BD5;sock&#x662F;&#x5426;&#x53EF;&#x8BFB;&#x5199;&#xFF0C;&#x8FD9;3&#x4E2A;&#x64CD;&#x4F5C;&#x90FD;&#x662F;O(1)&#x7684;&#x6548;&#x7387;&#x3002;  </p>
<p>&#x53EF;&#x60DC;&#x8FD9;&#x4E9B;&#x4F18;&#x5316;&#x7684;&#x65B9;&#x6848;&#xFF0C;&#x90FD;&#x4E0D;&#x662F;&#x6807;&#x51C6;&#x3002;linux&#x4F7F;&#x7528;epoll()&#xFF0C;BSDs(&#x5305;&#x62EC;&#x82F9;&#x679C;&#x5185;&#x6838;)&#x4F7F;&#x7528;kqueue()&#xFF0C;Solaris&#x4F7F;&#x7528;evports&#x548C;/dev/poll&#xFF0C; &#x81F4;&#x547D;&#x7684;&#x662F;&#xFF0C;&#x540C;&#x4E2A;&#x7CFB;&#x7EDF;&#x53EA;&#x4F7F;&#x7528;&#x4ED6;&#x4EEC;&#x7684;&#x4F18;&#x5316;&#x65B9;&#x6848;&#xFF0C;&#x4E0D;&#x5305;&#x62EC;&#x5176;&#x4ED6;&#xFF0C;&#x6BD4;&#x5982;linux&#x4E0A;&#x5C31;&#x6CA1;&#x6709;&#x4F7F;&#x7528;kqueue()&#x3002;  </p>
<p>&#x6240;&#x4EE5;&#xFF0C;&#x5982;&#x679C;&#x4F60;&#x60F3;&#x8981;&#x5199;&#x4E00;&#x4E2A;&#x9AD8;&#x6027;&#x80FD;&#x5F02;&#x6B65;IO&#x7684;&#x7A0B;&#x5E8F;&#xFF0C;&#x82E5;&#x8003;&#x8651;&#x79FB;&#x690D;&#x548C;&#x8DE8;&#x5E73;&#x53F0;&#xFF0C;&#x4F60;&#x8FD8;&#x9700;&#x8981;&#x505A;&#x4E00;&#x4E9B;&#x989D;&#x5916;&#x7684;&#x5305;&#x88C5;&#x3002;  </p>
<p><strong>&#x4E8E;&#x662F;&#xFF0C;Libevent&#x7684;API&#x505A;&#x4E86;&#x4E0A;&#x9762;&#x63D0;&#x5230;&#x7684;&#x8FD9;&#x4E9B;&#x3002;</strong></p>
<p>&#x9A6C;&#x4E0A;&#x518D;&#x770B;&#x4E00;&#x4E2A;&#x5F02;&#x6B65;IO&#x7684;<strong>ROTI13</strong>&#x670D;&#x52A1;&#x7AEF;&#x4EE3;&#x7801;&#x3002;&#x8FD9;&#x6B21;&#x6211;&#x4EEC;&#x4F7F;&#x7528;Libevent2&#x6765;&#x4EE3;&#x66FF;select()&#x3002;&#x6CE8;&#x610F;fd_sets&#x88AB;&#x66FF;&#x6362;&#x4E86;&#xFF0C;&#x73B0;&#x5728;&#x4F7F;&#x7528;&#x7684;&#x662F;&#x4E8B;&#x4EF6;events&#x3002;</p>
<h4 id="example-a-low-level-rot13-server-with-libevent"><a href="#Example-A-low-level-ROT13-server-with-Libevent" class="headerlink" title="Example: A low-level ROT13 server with Libevent"></a>Example: A low-level ROT13 server with Libevent</h4><pre><code>/* For sockaddr_in */
#include &lt;netinet/in.h&gt;
/* For socket functions */
#include &lt;sys/socket.h&gt;
/* For fcntl */
#include &lt;fcntl.h&gt;

#include &lt;event2/event.h&gt;

#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

#define MAX_LINE 16384

void do_read(evutil_socket_t fd, short events, void *arg);
void do_write(evutil_socket_t fd, short events, void *arg);

char
rot13_char(char c)
{
    /* We don&apos;t want to use isalpha here; setting the locale would change
     * which characters are considered alphabetical. */
    if ((c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;m&apos;) || (c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;M&apos;))
        return c + 13;
    else if ((c &gt;= &apos;n&apos; &amp;&amp; c &lt;= &apos;z&apos;) || (c &gt;= &apos;N&apos; &amp;&amp; c &lt;= &apos;Z&apos;))
        return c - 13;
    else
        return c;
}

struct fd_state {
    char buffer[MAX_LINE];
    size_t buffer_used;

    size_t n_written;
    size_t write_upto;

    struct event *read_event;
    struct event *write_event;
};

struct fd_state *
alloc_fd_state(struct event_base *base, evutil_socket_t fd)
{
    struct fd_state *state = malloc(sizeof(struct fd_state));
    if (!state)
        return NULL;
    state-&gt;read_event = event_new(base, fd, EV_READ|EV_PERSIST, do_read, state);
    if (!state-&gt;read_event) {
        free(state);
        return NULL;
    }
    state-&gt;write_event =
        event_new(base, fd, EV_WRITE|EV_PERSIST, do_write, state);

    if (!state-&gt;write_event) {
        event_free(state-&gt;read_event);
        free(state);
        return NULL;
    }

    state-&gt;buffer_used = state-&gt;n_written = state-&gt;write_upto = 0;

    assert(state-&gt;write_event);
    return state;
}

void
free_fd_state(struct fd_state *state)
{
    event_free(state-&gt;read_event);
    event_free(state-&gt;write_event);
    free(state);
}

void
do_read(evutil_socket_t fd, short events, void *arg)
{
    struct fd_state *state = arg;
    char buf[1024];
    int i;
    ssize_t result;
    while (1) {
        assert(state-&gt;write_event);
        result = recv(fd, buf, sizeof(buf), 0);
        if (result &lt;= 0)
            break;

        for (i=0; i &lt; result; ++i)  {
            if (state-&gt;buffer_used &lt; sizeof(state-&gt;buffer))
                state-&gt;buffer[state-&gt;buffer_used++] = rot13_char(buf[i]);
            if (buf[i] == &apos;\n&apos;) {
                assert(state-&gt;write_event);
                event_add(state-&gt;write_event, NULL);
                state-&gt;write_upto = state-&gt;buffer_used;
            }
        }
    }

    if (result == 0) {
        free_fd_state(state);
    } else if (result &lt; 0) {
        if (errno == EAGAIN) /* XXXX use evutil macro */
            return;
        perror(&quot;recv&quot;);
        free_fd_state(state);
    }
}

void
do_write(evutil_socket_t fd, short events, void *arg)
{
    struct fd_state *state = arg;

    while (state-&gt;n_written &lt; state-&gt;write_upto) {
        ssize_t result = send(fd, state-&gt;buffer + state-&gt;n_written,
                              state-&gt;write_upto - state-&gt;n_written, 0);
        if (result &lt; 0) {
            if (errno == EAGAIN) /* XXX use evutil macro */
                return;
            free_fd_state(state);
            return;
        }
        assert(result != 0);

        state-&gt;n_written += result;
    }

    if (state-&gt;n_written == state-&gt;buffer_used)
        state-&gt;n_written = state-&gt;write_upto = state-&gt;buffer_used = 1;

    event_del(state-&gt;write_event);
}

void
do_accept(evutil_socket_t listener, short event, void *arg)
{
    struct event_base *base = arg;
    struct sockaddr_storage ss;
    socklen_t slen = sizeof(ss);
    int fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);
    if (fd &lt; 0) { // XXXX eagain??
        perror(&quot;accept&quot;);
    } else if (fd &gt; FD_SETSIZE) {
        close(fd); /* XXX replace all closes with EVUTIL_CLOSESOCKET */
    } else {
        struct fd_state *state;
        evutil_make_socket_nonblocking(fd);
        state = alloc_fd_state(base, fd);
        assert(state); /*XXX err*/
        assert(state-&gt;write_event);
        event_add(state-&gt;read_event, NULL);
    }
}

void
run(void)
{
    evutil_socket_t listener;
    struct sockaddr_in sin;
    struct event_base *base;
    struct event *listener_event;

    base = event_base_new();
    if (!base)
        return; /*XXXerr*/

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(40713);

    listener = socket(AF_INET, SOCK_STREAM, 0);
    evutil_make_socket_nonblocking(listener);

#ifndef WIN32
    {
        int one = 1;
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, sizeof(one));
    }
#endif

    if (bind(listener, (struct sockaddr*)&amp;sin, sizeof(sin)) &lt; 0) {
        perror(&quot;bind&quot;);
        return;
    }

    if (listen(listener, 16)&lt;0) {
        perror(&quot;listen&quot;);
        return;
    }

    listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (void*)base);
    /*XXX check it */
    event_add(listener_event, NULL);

    event_base_dispatch(base);
}

int
main(int c, char **v)
{
    setvbuf(stdout, NULL, _IONBF, 0);

    run();
    return 0;
}
</code></pre><p>&#x6CE8;&#x610F;&#x5230;&#xFF0C;sockets&#x7684;&#x6570;&#x636E;&#x7C7B;&#x578B;&#x4E0D;&#x662F;<strong>int</strong>&#xFF0C;&#x6211;&#x4EEC;&#x505A;&#x4E86;&#x5305;&#x88C5;: <strong>evutil_socket_t</strong>&#xFF1B; &#x4E0D;&#x662F;&#x4F7F;&#x7528;<code>fcntl(O_NONBLOCK)</code>&#x6765;&#x8BBE;&#x7F6E;sock&#x975E;&#x963B;&#x585E;&#xFF0C;&#x66FF;&#x6362;&#x6210;<code>evutil_make_socket_nonblocking</code>&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x3002;&#x8FD9;&#x4E9B;&#x5C01;&#x88C5;&#xFF0C;&#x8BA9;&#x8FD9;&#x4E2A;&#x7A0B;&#x5E8F;&#x4E5F;&#x80FD;&#x517C;&#x5BB9;windows&#x7684;API&#x3002;</p>
<p><br></p>
<h2 id="&#x4F7F;&#x7528;libevent&#x65B9;&#x4FBF;&#x5417;&#x5728;windows&#x4E0B;&#x53C8;&#x5982;&#x4F55;"><a href="#&#x4F7F;&#x7528;Libevent&#x65B9;&#x4FBF;&#x5417;&#xFF0C;&#x5728;Windows&#x4E0B;&#x53C8;&#x5982;&#x4F55;" class="headerlink" title="&#x4F7F;&#x7528;Libevent&#x65B9;&#x4FBF;&#x5417;&#xFF0C;&#x5728;Windows&#x4E0B;&#x53C8;&#x5982;&#x4F55;"></a>&#x4F7F;&#x7528;Libevent&#x65B9;&#x4FBF;&#x5417;&#xFF0C;&#x5728;Windows&#x4E0B;&#x53C8;&#x5982;&#x4F55;</h2><p>&#x4E5F;&#x8BB8;&#x4F60;&#x6CE8;&#x610F;&#x5230;&#x6700;&#x540E;&#x7684;&#x4EE3;&#x7801;&#x66F4;&#x4E3A;&#x9AD8;&#x6548;&#xFF0C;&#x4E5F;&#x66F4;&#x4E3A;&#x590D;&#x6742;&#x3002;  </p>
<p>&#x56DE;&#x8FC7;&#x5934;&#x6765;&#x770B;&#xFF0C;&#x6211;&#x4EEC;&#x5E76;&#x6CA1;&#x6709;&#x4E3A;&#x6BCF;&#x4E2A;&#x8FDE;&#x63A5;&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;buffer&#xFF0C;&#x6BCF;&#x4E2A;&#x8FDB;&#x7A0B;&#x53EA;&#x662F;&#x4F7F;&#x7528;&#x4E00;&#x4EFD;&#x6808;&#x4E0A;&#x5206;&#x914D;&#x7684;&#x5185;&#x5B58;&#x3002;&#x4E0D;&#x9700;&#x8981;&#x7CBE;&#x51C6;&#x8DDF;&#x8E2A;&#x5F53;&#x524D;&#x662F;&#x54EA;&#x4E2A;sock&#x7684;&#x8BFB;&#x5199;&#xFF0C;&#x4E5F;&#x4E0D;&#x9700;&#x8DDF;&#x8E2A;&#x5F53;&#x524D;&#x6709;&#x591A;&#x5C11;sock&#x5B8C;&#x6210;&#x4E86;&#x64CD;&#x4F5C;&#xFF0C;&#x6211;&#x4EEC;&#x53EA;&#x662F;&#x5FAA;&#x73AF;&#xFF0C;&#x63A8;&#x51FA;&#x6808;&#x4E0A;&#x7684;&#x53D8;&#x91CF;&#x3002;  </p>
<p>&#x8FD8;&#x6709;&#xFF0C;&#x5982;&#x679C;&#x4F60;&#x6709;Windows&#x4E30;&#x5BCC;&#x7684;&#x7F51;&#x7EDC;&#x7F16;&#x7A0B;&#x7ECF;&#x9A8C;&#xFF0C;&#x4F60;&#x5C06;&#x4F1A;&#x6CE8;&#x610F;&#x5230;&#xFF0C;&#x6309;&#x4E0A;&#x9762;&#x7684;&#x6A21;&#x578B;&#x4F7F;&#x7528;Libevent&#x5199;&#x7684;&#x7A0B;&#x5E8F;&#xFF0C;&#x5728;Windows&#x4E0B;&#x53EF;&#x80FD;&#x4E0D;&#x4F1A;&#x6709;&#x5F88;&#x597D;&#x7684;&#x6027;&#x80FD;&#x3002;&#x5728;Windows&#x4E0B;&#x5E76;&#x4E0D;&#x662F;&#x4F7F;&#x7528;&#x7C7B;&#x4F3C;select&#x7684;&#x8C03;&#x7528;&#x6765;&#x5B9E;&#x73B0;&#x5FEB;&#x901F;&#x5F02;&#x6B65;IO&#xFF0C;&#x800C;&#x662F;&#x4F7F;&#x7528;IOCP (IO Completion Ports)&#x8FD9;&#x4E2A;API&#x3002; </p>
<p>&#x4E0D;&#x50CF;&#x5176;&#x4ED6;&#x6240;&#x6709;&#x7684;&#x5FEB;&#x901F;&#x7F51;&#x7EDC;API&#xFF0C;IOCP&#x5E76;&#x4E0D;&#x4F1A;&#x901A;&#x77E5;&#x4F60;&#x7684;&#x7A0B;&#x5E8F;&#x8BF4;&#x54EA;&#x4E9B;sock&#x51C6;&#x5907;&#x597D;&#x8BFB;&#x5199;&#x4E86;&#x3002;&#x53CD;&#x8FC7;&#x6765;&#xFF0C;&#x9700;&#x8981;&#x5148;&#x7531;&#x7A0B;&#x5E8F;&#x544A;&#x8BC9;Windows networking stack&#x5F00;&#x59CB;&#x7F51;&#x7EDC;&#x64CD;&#x4F5C;&#xFF0C;&#x7136;&#x540E;&#x7531;IOCP&#x6765;&#x544A;&#x77E5;&#x54EA;&#x4E9B;&#x64CD;&#x4F5C;&#x5B8C;&#x6210;&#x4E86;&#x3002;&#xFF08;popozhu&#x6CE8;&#xFF1A;&#x6211;&#x7684;&#x7406;&#x89E3;&#x662F;&#xFF0C;linux&#x662F;&#x7B49;&#x5185;&#x6838;&#x901A;&#x77E5;&#x4F60;&#x53EF;&#x4EE5;&#x8BFB;&#x6216;&#x5199;&#xFF0C;&#x8BFB;&#x5199;&#x64CD;&#x4F5C;&#x53EF;&#x4EE5;&#x9A6C;&#x4E0A;&#x975E;&#x963B;&#x585E;&#x5730;&#x8FD4;&#x56DE;&#xFF0C;&#x800C;Windows&#x5219;&#x662F;&#x7A0B;&#x5E8F;&#x5148;&#x505A;&#x8BFB;&#x6216;&#x5199;&#xFF0C;&#x7136;&#x540E;&#x7A0B;&#x5E8F;&#x82E6;&#x7B49;IOCP&#x628A;&#x6267;&#x884C;&#x7ED3;&#x679C;&#x544A;&#x77E5;&#x7A0B;&#x5E8F;&#x3002;&#x524D;&#x8005;&#x662F;&#x53D1;&#x8D77;&#x8BFB;&#x5199;&#xFF0C;&#x540E;&#x8005;&#x662F;&#x7ED3;&#x675F;&#x8BFB;&#x5199;&#xFF0C;&#x540E;&#x8005;&#x53EF;&#x80FD;&#x5B58;&#x5728;&#x7B49;&#x5F85;&#x5427;)&#x3002;</p>
<p>&#x5E78;&#x8FD0;&#x7684;&#x662F;&#xFF0C;Libevent2 &#x201C;bufferevents&#x201D;&#x7684;&#x63A5;&#x53E3;&#x89E3;&#x51B3;&#x4E86;&#x8FD9;&#x4E2A;&#x95EE;&#x9898;&#xFF0C;&#x8BA9;&#x63A5;&#x53E3;&#x66F4;&#x5BB9;&#x6613;&#x4F7F;&#x7528;&#xFF0C;&#x800C;&#x4E14;&#x63D0;&#x4F9B;&#x4E86;&#x9002;&#x7528;&#x4E8E;linux&#x548C;windows&#x7684;&#x9AD8;&#x6548;&#x63A5;&#x53E3;&#x3002;<br>&#x4E8E;&#x662F;&#xFF0C;<strong>ROT13</strong>&#x670D;&#x52A1;&#x7AEF;&#x4EE3;&#x7801;&#x6700;&#x7EC8;&#x7248;&#xFF0C;&#x4F7F;&#x7528;bufferevents&#x8FD9;&#x4E2A;API&#x3002;  </p>
<h4 id="example-a-simpler-rot13-server-with-libevent"><a href="#Example-A-simpler-ROT13-server-with-Libevent" class="headerlink" title="Example: A simpler ROT13 server with Libevent"></a>Example: A simpler ROT13 server with Libevent</h4><pre><code>/* For sockaddr_in */
#include &lt;netinet/in.h&gt;
/* For socket functions */
#include &lt;sys/socket.h&gt;
/* For fcntl */
#include &lt;fcntl.h&gt;

#include &lt;event2/event.h&gt;
#include &lt;event2/buffer.h&gt;
#include &lt;event2/bufferevent.h&gt;

#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

#define MAX_LINE 16384

void do_read(evutil_socket_t fd, short events, void *arg);
void do_write(evutil_socket_t fd, short events, void *arg);

char
rot13_char(char c)
{
    /* We don&apos;t want to use isalpha here; setting the locale would change
     * which characters are considered alphabetical. */
    if ((c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;m&apos;) || (c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;M&apos;))
        return c + 13;
    else if ((c &gt;= &apos;n&apos; &amp;&amp; c &lt;= &apos;z&apos;) || (c &gt;= &apos;N&apos; &amp;&amp; c &lt;= &apos;Z&apos;))
        return c - 13;
    else
        return c;
}

void
readcb(struct bufferevent *bev, void *ctx)
{
    struct evbuffer *input, *output;
    char *line;
    size_t n;
    int i;
    input = bufferevent_get_input(bev);
    output = bufferevent_get_output(bev);

    while ((line = evbuffer_readln(input, &amp;n, EVBUFFER_EOL_LF))) {
        for (i = 0; i &lt; n; ++i)
            line[i] = rot13_char(line[i]);
        evbuffer_add(output, line, n);
        evbuffer_add(output, &quot;\n&quot;, 1);
        free(line);
    }

    if (evbuffer_get_length(input) &gt;= MAX_LINE) {
        /* Too long; just process what there is and go on so that the buffer
         * doesn&apos;t grow infinitely long. */
        char buf[1024];
        while (evbuffer_get_length(input)) {
            int n = evbuffer_remove(input, buf, sizeof(buf));
            for (i = 0; i &lt; n; ++i)
                buf[i] = rot13_char(buf[i]);
            evbuffer_add(output, buf, n);
        }
        evbuffer_add(output, &quot;\n&quot;, 1);
    }
}

void
errorcb(struct bufferevent *bev, short error, void *ctx)
{
    if (error &amp; BEV_EVENT_EOF) {
        /* connection has been closed, do any clean up here */
        /* ... */
    } else if (error &amp; BEV_EVENT_ERROR) {
        /* check errno to see what error occurred */
        /* ... */
    } else if (error &amp; BEV_EVENT_TIMEOUT) {
        /* must be a timeout event handle, handle it */
        /* ... */
    }
    bufferevent_free(bev);
}

void
do_accept(evutil_socket_t listener, short event, void *arg)
{
    struct event_base *base = arg;
    struct sockaddr_storage ss;
    socklen_t slen = sizeof(ss);
    int fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);
    if (fd &lt; 0) {
        perror(&quot;accept&quot;);
    } else if (fd &gt; FD_SETSIZE) {
        close(fd);
    } else {
        struct bufferevent *bev;
        evutil_make_socket_nonblocking(fd);
        bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
        bufferevent_setcb(bev, readcb, NULL, errorcb, NULL);
        bufferevent_setwatermark(bev, EV_READ, 0, MAX_LINE);
        bufferevent_enable(bev, EV_READ|EV_WRITE);
    }
}

void
run(void)
{
    evutil_socket_t listener;
    struct sockaddr_in sin;
    struct event_base *base;
    struct event *listener_event;

    base = event_base_new();
    if (!base)
        return; /*XXXerr*/

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(40713);

    listener = socket(AF_INET, SOCK_STREAM, 0);
    evutil_make_socket_nonblocking(listener);

#ifndef WIN32
    {
        int one = 1;
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, sizeof(one));
    }
#endif

    if (bind(listener, (struct sockaddr*)&amp;sin, sizeof(sin)) &lt; 0) {
        perror(&quot;bind&quot;);
        return;
    }

    if (listen(listener, 16)&lt;0) {
        perror(&quot;listen&quot;);
        return;
    }

    listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (void*)base);
    /*XXX check it */
    event_add(listener_event, NULL);

    event_base_dispatch(base);
}

int
main(int c, char **v)
{
    setvbuf(stdout, NULL, _IONBF, 0);

    run();
    return 0;
}
</code></pre><p><br></p>
<h2 id="&#x771F;&#x7684;&#x6709;&#x8FD9;&#x4E48;&#x9AD8;&#x6548;&#x7387;"><a href="#&#x771F;&#x7684;&#x6709;&#x8FD9;&#x4E48;&#x9AD8;&#x6548;&#x7387;&#xFF1F;" class="headerlink" title="&#x771F;&#x7684;&#x6709;&#x8FD9;&#x4E48;&#x9AD8;&#x6548;&#x7387;&#xFF1F;"></a>&#x771F;&#x7684;&#x6709;&#x8FD9;&#x4E48;&#x9AD8;&#x6548;&#x7387;&#xFF1F;</h2><p>&#x5B98;&#x65B9;&#x538B;&#x6D4B;&#x6587;&#x6863;&#x662F;&#x5F88;&#x4E45;&#x4E4B;&#x524D;&#x7684;&#x4E86;&#xFF0C;&#x6587;&#x6863;&#x4F5C;&#x8005;&#x8868;&#x793A;&#x6000;&#x7591;&#x3002;</p>
<p>&#x2013; EOF &#x2013;</p>

	

	<div>
	    <div>Categories: <a class="category-link" href="/categories/in-lib/">in_lib</a> </div>
	    <div>Tags: <a class="tag-link" href="/tags/libevent/">libevent</a> </div>
	</div>
    </div>

    <hr />
    <footer class="article-footer">
      
        <a href="http://popozhu.github.io/2013/06/09/Libevent_第2节_说说异步io/#disqus_thread" class="article-comment-link"></a>
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2013/06/10/libevent_r0_引言/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-caption">&laquo;</span>
      <span class="article-nav-title">
        
          Libevent引言
        
      </span>
    </a>
  
  
    <a href="/2013/06/09/Libevent_第1节_关于这份文档/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">关于这份文档</span>
      <span class="article-nav-caption">&raquo;</span>
    </a>
  
</nav>


  
</article>


<section id="comments">
  <div id="disqus_thread"> </div>
</section>


</section>

	    <footer id="footer">
    popozhu &copy; 2016 
</footer>

	</div>

	
<!--
<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js" type="text/javascript"></script>
-->


<script>
  var disqus_shortname = 'popozhu';
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


<script src="/js/script.js"></script>


    </body>
</html>
