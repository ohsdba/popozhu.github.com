<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    

    <title>Libevent创建event_base | popozhu</title>

    

    <link href="http://fonts.useso.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/css/style.css" type="text/css">

    </head>

    <body>
	<div class="container">
	    <div class="banner">
    <div>
        <span class="site-title"> <a href="/" id="logo">popozhu</a> </span>

        
    </div>

    <div class="banner-right">
        <span class="banner-item"> <a href="/archives"> Misc </a> </span>
        <span class="banner-item"> <a href="/about"> About </a> </span>
    </div>
</div>


	    <section id="main"><article class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
	<header class="article-header">
	    <div class="article-title">
		<div class="title">Libevent创建event_base</div> 
		<small>
		    <time datetime="2013-06-11T13:39:43.000Z" itemprop="datePublished">June 11 2013</time>
		</small>
	    </div>
	</header>
    

    <div class="article-entry" itemprop="articleBody">
	
	    
	    
		<div class="article-toc"> Toc <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建一个event_base"><span class="toc-text">创建一个event_base</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#event_base默认设置"><span class="toc-text">event_base默认设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#event_base更多设置"><span class="toc-text">event_base更多设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Example:_Preferring_edge-triggered_backends"><span class="toc-text">Example: Preferring edge-triggered backends</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example:_Avoiding_priority-inversion"><span class="toc-text">Example: Avoiding priority-inversion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检查event_base的后端函数"><span class="toc-text">检查event_base的后端函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Example"><span class="toc-text">Example</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inteface"><span class="toc-text">Inteface</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Example-1"><span class="toc-text">Example</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#释放event_base"><span class="toc-text">释放event_base</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设置event_base优先级"><span class="toc-text">设置event_base优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fock()之后重新初始化event_base"><span class="toc-text">fock()之后重新初始化event_base</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Example-2"><span class="toc-text">Example</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不再使用event_base这个函数"><span class="toc-text">不再使用event_base这个函数</span></a></li></ol> </div>
	    

	    <blockquote>
<p>原文：<a href="http://www.wangafu.net/~nickm/libevent-book/Ref2_eventbase.html" target="_blank" rel="external">R2: Getting an event_base</a></p>
</blockquote>
<h2 id="创建一个event_base">创建一个event_base</h2><p>在使用Libevent的接口前，你需要先创建一个或多个event_base数据结构。每个event_base持有一个sock集，可以轮询这个集合的sock来检查可以激活哪些事件。  </p>
<p>如果在event_base中设置使用锁，那在多个线程中可以使用这个event_base。 但是event_base只能在单个线程中进行轮询。 如果你想在多个线程中为你的IO做轮询，那你需要为每个线程创建一个event_base。  </p>
<p><strong>提示</strong>： Libevent的未来版本中可能支持在多个线程中使用同个event_base进行轮询。  </p>
<p>每个event_base有一个“方法”，或者说后端，用来检测哪个事件已经准备好了。 这个方法对应封装有（后文提到的“后端”，指代的是下面的一个或多个实现）：  </p>
<ol>
<li>select</li>
<li>poll</li>
<li>epoll</li>
<li>kqueue</li>
<li>devpoll</li>
<li>evport</li>
<li>win32</li>
</ol>
<p>用户可以通过设置环境变量来禁用某些后端。 比如你想要禁用kqueue这个后端， 可以通过设置<code>EVENT_NOKQUEUE</code>这个环境变量，其他的类似。如果你想在程序中禁用后端， 查看下面的<code>event_config_avoid_method()</code>.  </p>
<p><br></p>
<h2 id="event_base默认设置">event_base默认设置</h2><p>函数<code>event_base_new()</code>创建并返回一个带有默认设置的event_base。 它先检查你的环境变量，然后返回一个指针，指向这个新创建的event_base。 如果出现错误，返回一个NULL指针。  </p>
<p>对于上面提到的不同后端，它会选择一个当前系统支持的最高效率的后端来创建event_base。  </p>
<pre><code>struct event_base *event_base_new(void);
</code></pre><p>对于多数程序，创建一个默认设置的event_base已经足够了。　　<br><code>event_base_new()</code>定义在头文件<code>&lt;event2/event.h&gt;</code>中，首次出现在Libevent 1.4.3.  </p>
<p><br></p>
<h2 id="event_base更多设置">event_base更多设置</h2><p>如果你想对于创建哪种event_base有更多操作，那需要使用event_config。 event_config这个数据结构屏蔽和封装了你对event_base的设置选项。   </p>
<pre><code>struct event_config *event_config_new(void);
struct event_base *event_base_new_with_config(const struct event_config *cfg);
void event_config_free(struct event_config *cfg);
</code></pre><p>先调用<code>event_config_new()</code>创建一个event_config，再对event_config调用其他函数来进行你的设置，最后调用<code>event_base_new_with_config()</code>来创建一个event_base。最后调用<code>event_config_free()</code>来释放event_config。  </p>
<pre><code>int event_config_avoid_method(struct event_config *cfg, const char *method);

enum event_method_feature {
    EV_FEATURE_ET = 0x01,
    EV_FEATURE_O1 = 0x02,
    EV_FEATURE_FDS = 0x04,
};
int event_config_require_features(struct event_config *cfg,
                                  enum event_method_feature feature);

enum event_base_config_flag {
    EVENT_BASE_FLAG_NOLOCK = 0x01,
    EVENT_BASE_FLAG_IGNORE_ENV = 0x02,
    EVENT_BASE_FLAG_STARTUP_IOCP = 0x04,
    EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08,
    EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10,
    EVENT_BASE_FLAG_PRECISE_TIMER = 0x20
};
int event_config_set_flag(struct event_config *cfg,
    enum event_base_config_flag flag);
</code></pre><p>调用<code>event_config_avoid_method()</code>来忽略指定名称的后端。调用<code>event_config_require_feature()</code>来设置Libevent不要使用不满足一些特性的那些后端。调用<code>event_config_set_flag()</code>来告诉Libevent使用一个或多个运行时标识来创建event_base。  </p>
<p><code>event_config_require_features</code>可使用的特性有：  </p>
<ol>
<li>EV_FEATURE_ET： 要求后端能支持边沿触发IO(edge-triggered IO)</li>
<li>EV_FEATURE_O1： 要求增加活删除一个事件，或者激活事件时，后端要满足O(1)的效率</li>
<li>EV_FEATURE_FDS： 要求后端能支持任意类型的文件描述符，而不仅仅是socket</li>
</ol>
<p><code>event_config_set_flag()</code>可使用的运行时标识有：  </p>
<ol>
<li><p>EVENT_BASE_FLAG_NOLOCK<br> 设置event_base不要使用锁。使用这个标识可以在加锁和释放event_base时节省一些时间，但在多线程中使用同个event_base会变得不安全，也无法加锁其实。  </p>
</li>
<li><p>EVENT_BASE_FLAG_IGNORE<em>ENV<br> 在选择后端时不要检查以`EVENT</em>`开头的环境变量。谨慎使用这个标识，它将增加你调试代码和Libevent接口的难度。  </p>
</li>
<li><p>EVENT_BASE_FLAG_STARTUP_IOCP<br>只限Windows上使用，让Libevent运行后自动在需要时使用IOCP分发逻辑。  </p>
</li>
<li><p>EVENT_BASE_FLAG_NO_CACHE_TIME<br> 设置这个标识，则每次轮询超时之后检查当前时间，而不是每次在每次轮询超时时做检查。这将使用更多cpu，使用时注意一下。  </p>
</li>
<li><p>EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST<br> 告诉Libevent，如果它决定使用epoll这个后端，那它可以安全使用这类基于”changelist”的后端。在后端的分发函数被调用期间，若同个fd的状态被多次修改，那这个epoll-changelist后端能够避免一些不必要系统调用；但它也触发一个内核的bug：如果传一个通过<code>dup()</code>或类似的函数来clone的fd给到Libevent，将导致错误的结果。如果你不是使用epoll这个后端，那这个标识没有效果。你也可以通过设置<code>EVENT_EPOLL_USE_CHANGELIST</code>这个环境变量来打开epoll-changelist选项。  </p>
</li>
<li><p>EVENT_BASE_FLAG_PRECISE_TIMER<br> Libevent默认尝试使用系统提供的快速分时机制。如果有一个慢一些的但能提供更为精细度的分时机制，那通过这个标识来告诉Libevent使用这个慢一些的。如果系统不支持”慢一些但更精细”的机制，则这个标识没有效果。  </p>
</li>
</ol>
<p>上面设置event_config的函数，成功则返回0，失败返回-1。  </p>
<p><strong>注意</strong><br>如果你通过event_config设置一个系统不支持的后端，那<code>event_base_new_with_config()</code>返回NULL指针。  </p>
<pre><code>int event_config_set_num_cpus_hint(struct event_config *cfg, int cpus)
</code></pre><p>这个函数目前只当Windows使用IOCP时才有用，未来也许用于其他系统。 调用他来告诉event_config后续创建的event_base应该在多线程中尝试充分使用cpu的多核。 注意event_base可能使用比你设置的更多或更少的cpu。    </p>
<pre><code>int event_config_set_max_dispatch_interval(struct event_config *cfg,
    const struct timeval *max_interval, int max_callbacks,
    int min_priority);
</code></pre><p>这个函数通过在检查高优先级事件之前，对低优先级回调函数可以被调用的次数进行限制，来防止优先级的逆转。如果最大时间间隔为空，则事件轮询会在每个回调之后检查时间；如果最大时间间隔不为空，则会在这个时间间隔之后重新扫描高优先级的事件。如果最多回调次数不为负数，那达到这个次数之后，事件继续轮询更多事件。这些规则适用于最小优先级或更高优先级的任何事件。</p>
<h3 id="Example:_Preferring_edge-triggered_backends">Example: Preferring edge-triggered backends</h3><pre><code>struct event_config *cfg;
struct event_base *base;
int i;

/* My program wants to use edge-triggered events if at all possible.  So
   I&#39;ll try to get a base twice: Once insisting on edge-triggered IO, and
   once not. */
for (i=0; i&lt;2; ++i) {
    cfg = event_config_new();

    /* I don&#39;t like select. */
    event_config_avoid_method(cfg, &quot;select&quot;);

    if (i == 0)
        event_config_require_features(cfg, EV_FEATURE_ET);

    base = event_base_new_with_config(cfg);
    event_config_free(cfg);
    if (base)
        break;

    /* If we get here, event_base_new_with_config() returned NULL.  If
       this is the first time around the loop, we&#39;ll try again without
       setting EV_FEATURE_ET.  If this is the second time around the
       loop, we&#39;ll give up. */
}
</code></pre><h3 id="Example:_Avoiding_priority-inversion">Example: Avoiding priority-inversion</h3><pre><code>struct event_config *cfg;
struct event_base *base;

cfg = event_config_new();
if (!cfg)
   /* Handle error */;

/* I&#39;m going to have events running at two priorities.  I expect that
   some of my priority-1 events are going to have pretty slow callbacks,
   so I don&#39;t want more than 100 msec to elapse (or 5 callbacks) before
   checking for priority-0 events. */
struct timeval msec_100 = { 0, 100*1000 };
event_config_set_max_dispatch_interval(cfg, &amp;msec_100, 5, 1);

base = event_base_new_with_config(cfg);
if (!base)
   /* Handle error */;

event_base_priority_init(base, 2);
</code></pre><p>这些函数和类型定义在头文件<code>&lt;event2/event.h&gt;</code>。  </p>
<p>标识<code>EVENT_BASE_FLAG_IGNORE_ENV</code>首先出现在Libevent 2.0.2-alpha。<br>标识<code>EVENT_BASE_FLAG_PRECISE_TIMER</code>首次出现在Libevent 2.1.2-alpha。<br>函数<code>event_config_set_num_cpus_hint()</code>是在Libevent 2.0.7-rc才有，以及函数<code>event_config_set_max_dispatch_interval()</code>首先出现在2.1.1-alpha。<br>其他的则都是首次出现在Libevent 2.0.1-alpha。  </p>
<p><br></p>
<h2 id="检查event_base的后端函数">检查event_base的后端函数</h2><p>有时你想查看event_base有哪些特性，或者event_base使用了哪个后端函数。  </p>
<pre><code>const char **event_get_supported_methods(void);
</code></pre><p>函数返回一个数组指针，数组包含当前Libevent支持的后端函数。数组最后一个元素是NULL指针。  </p>
<h4 id="Example">Example</h4><pre><code>int i;
const char **methods = event_get_supported_methods();
printf(&quot;Starting Libevent %s.  Available methods are:\n&quot;,
    event_get_version());
for (i=0; methods[i] != NULL; ++i) {
    printf(&quot;    %s\n&quot;, methods[i]);
}
</code></pre><p><strong>注意</strong>: 这个函数返回的是Libevent编译中支持的后端函数列表，</p>
<h3 id="Inteface">Inteface</h3><pre><code>const char *event_base_get_method(const struct event_base *base);
enum event_method_feature event_base_get_features(const struct event_base *base);
</code></pre><p><code>event_base_get_method()</code>返回event_base实际使用的后端函数。<br><code>The event_base_get_features()</code>返回一个位掩码，标识event_base支持的特性。  </p>
<h4 id="Example-1">Example</h4><pre><code>struct event_base *base;
enum event_method_feature f;

base = event_base_new();
if (!base) {
    puts(&quot;Couldn&#39;t get an event_base!&quot;);
} else {
    printf(&quot;Using Libevent with backend method %s.&quot;,
        event_base_get_method(base));
    f = event_base_get_features(base);
    if ((f &amp; EV_FEATURE_ET))
        printf(&quot;  Edge-triggered events are supported.&quot;);
    if ((f &amp; EV_FEATURE_O1))
        printf(&quot;  O(1) event notification is supported.&quot;);
    if ((f &amp; EV_FEATURE_FDS))
        printf(&quot;  All FD types are supported.&quot;);
    puts(&quot;&quot;);
}
</code></pre><p><br></p>
<h2 id="释放event_base">释放event_base</h2><p>event_base不再使用时，你可以释放它.  </p>
<pre><code>void event_base_free(struct event_base *base);
</code></pre><p>注意这个函数并不会同时释放当前关联在这个event_base上的事件，不会关闭任何socket。  </p>
<p><br></p>
<h2 id="设置event_base优先级">设置event_base优先级</h2><p>Libevent支持对一个event设置多个优先顺序，但是默认上一个event_base只支持一个优先等级。你可以调用<code>event_base_priority_init()</code>来设置event_base的优先级。  </p>
<pre><code>int event_base_priority_init(struct event_base *base, int n_priorities);
</code></pre><p>成功返回0，否则返回-1。 参数base指event_base，n_priorities是优先级对应的数字，至少为1。<br>新创建的事件的优先级则是从最重要的0到不重要的-1.<br>有一个常量<code>EVENT_MAX_PRIORITIES</code>, 是参数n_priorities的最大值，n_priorities不能超过这个值。<br><strong>注意</strong>： 你必须在激活任何事件之前调用这个函数，最好是在event_base创建之后马上调用。  </p>
<pre><code>int event_base_get_npriorities(struct event_base *base);
</code></pre><p>返回event_base的优先等级。例如：如果返回3，则有效的优先顺序范围为0，1，2.<br>新创建的事件关联到这个event_base后，事件的默认优先级初始化为<code>n_priorities / 2</code>.  </p>
<p><br></p>
<h2 id="fock()之后重新初始化event_base">fock()之后重新初始化event_base</h2><p>在fork()之后并不是所有的事件后端都能保持干净，所以，如果你的程序使用fork()或者相关联的系统调用来开始一个新的进程，而且你想继续使用之前的event_base，那你需要重新初始化event_base。  </p>
<pre><code>int event_reinit(struct event_base *base);
</code></pre><p>成功返回0，失败返回-1。  </p>
<h4 id="Example-2">Example</h4><pre><code>struct event_base *base = event_base_new();

/* ... add some events to the event_base ... */

if (fork()) {
    /* In parent */
    continue_running_parent(base); /*...*/
} else {
    /* In child */
    event_reinit(base);
    continue_running_child(base); /*...*/
}
</code></pre><p><br></p>
<h2 id="不再使用event_base这个函数">不再使用event_base这个函数</h2><p>以前使用的是<code>struct event_base *event_init(void);</code><br>解释略。</p>
<p><br><br>– EOF –</p>

	

	<div>
	    <div>Categories: <a class="category-link" href="/categories/in-lib/">in_lib</a> </div>
	    <div>Tags:<a class="tag-link" href="/tags/libevent/">libevent</a> </div>
	</div>
    </div>

    <hr />
    <footer class="article-footer">
      
        <a href="http://popozhu.github.io/2013/06/11/libevent_r2_创建event_base/#disqus_thread" class="article-comment-link"></a>
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2013/06/12/libevent_r3_事件轮询/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-caption">&laquo;</span>
      <span class="article-nav-title">
        
          Libevent事件轮询
        
      </span>
    </a>
  
  
    <a href="/2013/06/10/libevent_r1_全局参数/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">Libevent全局参数</span>
      <span class="article-nav-caption">&raquo;</span>
    </a>
  
</nav>


  
</article>


<section id="comments">
  <div id="disqus_thread"> </div>
</section>


</section>

	    <footer id="footer">
    popozhu &copy; 2016 
</footer>

	</div>

	
<!--
<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js" type="text/javascript"></script>
-->


<script>
  var disqus_shortname = 'popozhu';
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


<script src="/js/script.js" type="text/javascript"></script>

    </body>
</html>
