<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    

    <title>openssl和多线程 | popozhu</title>

    

    <link href="http://fonts.useso.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/css/style.css" type="text/css">

    </head>

    <body>
	<div class="container">
	    <div class="banner">
    <div>
        <span class="site-title"> <a href="/" id="logo">popozhu</a> </span>

        
    </div>

    <div class="banner-right">
        <span class="banner-item"> <a href="/archives"> Misc </a> </span>
        <span class="banner-item"> <a href="/about"> About </a> </span>
    </div>
</div>


	    <section id="main"><article class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
	<header class="article-header">
	    <div class="article-title">
		<div class="title">openssl和多线程</div> 
		<small>
		    <time datetime="2013-08-15T14:26:56.000Z" itemprop="datePublished">August 15 2013</time>
		</small>
	    </div>
	</header>
    

    <div class="article-entry" itemprop="articleBody">
	
	    
	    

	    <p>这星期在程序里的多线程使用openssl来进行ssl通信，看了一些openssl的文档，前两天领导提醒我注意使用锁，今晚发现openssl提供了非常简单的加锁方式：用户无需显式地进行加锁、解锁，只需提供2个回调函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="function"><span class="keyword">void</span> <span class="title">locking_function</span><span class="params">(<span class="keyword">int</span> mode, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) <span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">id_function</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>对openssl设置这2个回调函数，在需要加锁、解锁时，openssl自动调用这2个函数。于是，过程大概如下：  </p>
<ol>
<li>自己实现回调函数1: locking_function   </li>
<li>自己实现回调函数2: id_function   </li>
<li>设置回调函数   </li>
</ol>
<p><hr><br>上面的3个子过程大概又分别如下：  </p>
<ol>
<li><p>实现回调函数1: locking_function</p>
<pre><code><span class="comment">// 这个数组需要自己申请空间，后续给到openssl使用</span>
<span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> *ssl_lock = <span class="literal">NULL</span>;

<span class="function"><span class="keyword">void</span> <span class="title">locking_function</span><span class="params">(<span class="keyword">int</span> mode, <span class="keyword">int</span> type, <span class="keyword">char</span> *file, <span class="keyword">int</span> line)</span>
</span>{
    <span class="comment">// 根据第1个参数mode来判断是加锁还是解锁</span>
    <span class="comment">// 第2个参数是数组下标</span>
    <span class="keyword">if</span> (mode &amp; CRYPTO_LOCK){
        pthread_mutex_lock(&amp;(ssl_lock[type]));
    }<span class="keyword">else</span>{
        pthread_mutex_unlock(&amp;(ssl_lock[type]));
    }
}
</code></pre></li>
<li><p>实现回调函数2: id_function</p>
<pre><code><span class="comment">// 返回当前线程id</span>
<span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">id_function</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">unsigned</span> <span class="keyword">long</span> ret;

    ret=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)pthread_self();
    <span class="keyword">return</span>(ret);
}
</code></pre></li>
<li><p>设置回调函数</p>
<pre><code>int create_ssl_lock<span class="params">(void)</span>
{
    int i;

    <span class="comment">// 申请空间，锁的个数是：CRYPTO_num_locks()，</span>
    ssl_lock = OPENSSL_malloc<span class="params">(CRYPTO_num_locks<span class="params">()</span> * sizeof<span class="params">(pthread_mutex_t)</span>)</span>;
    <span class="keyword">if</span> <span class="params">(!ssl_lock)</span>
        return -<span class="number">1</span>;

    <span class="keyword">for</span> <span class="params">(i =<span class="number">0</span> ; i &lt; CRYPTO_num_locks<span class="params">()</span>; i++)</span>{
        pthread_mutex_init<span class="params">(&amp;<span class="params">(ssl_lock[i])</span>, NULL)</span>;
    }

    <span class="comment">// 设置回调函数，获取当前线程id</span>
    CRYPTO_set_id_callback<span class="params">(<span class="params">(unsigned long <span class="params">(*)</span><span class="params">()</span>)</span>id_function)</span>;

    <span class="comment">// 设置回调函数，加锁和解锁</span>
    CRYPTO_set_locking_callback<span class="params">(<span class="params">(void <span class="params">(*)</span><span class="params">()</span>)</span>locking_function)</span>;
    return <span class="number">0</span>;
}
</code></pre></li>
<li><p>释放资源</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">ssl_lock_cleanup</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">int</span> i;

    <span class="keyword">if</span> (!ssl_lock){
        <span class="keyword">return</span>;
    }

    CRYPTO_set_locking_callback(<span class="literal">NULL</span>);
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CRYPTO_num_locks(); i++){
        pthread_mutex_destroy(&amp;(ssl_lock[i]));
    }
    OPENSSL_free(ssl_lock);
    ssl_lock = <span class="literal">NULL</span>;
}
</code></pre></li>
</ol>
<p><hr><br>另外，在启动其他线程、初始化ssl之前调用<code>create_ssl_lock()</code>，在程序最后清理资源时调用<code>ssl_lock_cleanup()</code>。<br>最后总的流程大概为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main start:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_ssl_env</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    SSL_load_error_strings();</span><br><span class="line">    SSL_library_init();</span><br><span class="line">    OpenSSL_add_all_algorithms();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (create_ssl_lock())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create ssl lock buffer err:%m\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动其他工作线程</span></span><br><span class="line"><span class="comment">// 线程里初始化ssl、使用ssl（不需显式地进行加锁、解锁）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean_ssl_env</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ssl_lock_cleanup();</span><br><span class="line"></span><br><span class="line">    ERR_free_strings();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main end</span><br></pre></td></tr></table></figure></p>
<p>这里使用的是openssl的<strong>静态锁</strong>，固定申请<code>CRYPTO_num_locks()</code>这么多个锁。 当然也可以使用<strong>动态锁</strong>，对性能还有提高。<br>但是，openssl的<a href="http://www.openssl.org/docs/crypto/threads.html" target="_blank" rel="external">man页面</a>上说，openssl内部当前不使用动态锁，未来也许会使用：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Also, <span class="keyword">dynamic</span> locks are currently <span class="keyword">not</span> used internally <span class="keyword">by</span> OpenSSL, but may <span class="keyword">do</span> so <span class="keyword">in</span> the <span class="keyword">future</span>.</span><br></pre></td></tr></table></figure></p>
<p>参考自: <a href="http://my.safaribooksonline.com/book/networking/security/059600270x/support-infrastructure/openssl-chp-4-sect-1" target="_blank" rel="external">Multithread Support</a><br>ps，推荐上面这本书《Cryptography for Secure Communications》，这里是<a href="http://it-ebooks.info/book/263/" target="_blank" rel="external">pdf下载页面</a>。</p>
<p><br><br>– EOF –</p>

	

	<div>
	    <div>Categories: <a class="category-link" href="/categories/in-lib/">in_lib</a> </div>
	    <div>Tags:<a class="tag-link" href="/tags/c/">c</a>,<a class="tag-link" href="/tags/openssl/">openssl</a> </div>
	</div>
    </div>

    <hr />
    <footer class="article-footer">
      
        <a href="http://popozhu.github.io/2013/08/15/openssl和多线程/#disqus_thread" class="article-comment-link"></a>
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2013/08/24/ios消息并发推送/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-caption">&laquo;</span>
      <span class="article-nav-title">
        
          ios消息并发推送
        
      </span>
    </a>
  
  
    <a href="/2013/08/14/大端和小端/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">大端和小端</span>
      <span class="article-nav-caption">&raquo;</span>
    </a>
  
</nav>


  
</article>


<section id="comments">
  <div id="disqus_thread"> </div>
</section>


</section>

	    <footer id="footer">
    popozhu &copy; 2016 
</footer>

	</div>

	
<!--
<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js" type="text/javascript"></script>
-->


<script>
  var disqus_shortname = 'popozhu';
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


<script src="/js/script.js" type="text/javascript"></script>

    </body>
</html>
