<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    

    <title>ios消息推送的优化 | popozhu</title>

    

    <link href="http://fonts.useso.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/css/style.css" type="text/css">

    </head>

    <body>
	<div class="container">
	    <div class="banner">
    <span class="site-title"> <a href="/" id="logo">popozhu</a> </span>

    
    <span class="site-subtitle"> do not go gentle into that good night </span>
    
</div>


	    <section id="main"><article class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
	<header class="article-header">
	    <div class="article-title">
		<div class="title">ios消息推送的优化</div> 
		<small>
		    <time datetime="2014-12-27T15:44:09.000Z" itemprop="datePublished">December 27th 2014</time>
		</small>
	    </div>
	</header>
    

    <div class="article-entry" itemprop="articleBody">
	
	    <p>去年八月份写过一个 ios 消息批量推送的小程序（<a href="/2013/08/24/ios消息并发推送/">ios消息并发推送</a>)，使用的是 blocking IO， 效率一般，进程还可能长时间 block 在某次 IO 上。</p>
<h4>最近有空，做了下优化，主要包括：</h4>

<ol>
<li>使用 non-blocking IO，也即 non-blocking SSL 读和写，这次主要也是为了实践 SSL non-block 编程</li>
<li>尽可能排除无效 token，推送过程能收到应答，知道哪些是无效 token，在推送后清理这些 token，避免下次推送再遇到</li>
</ol>
<h4>值得一提的事项则有如下： </h4> 

<ol>
<li><p>在我尝试 non-blocking SSL 读写的实践中，建立 socket 连接、建立 ssl 连接，倒还是阻塞的方式，只是在读写推送数据时，才修改为非阻塞模式。因为建立 SSL 连接时会有一个握手过程，非阻塞模式需要中断几次，设置 SSL 让其静默地完成握手，简化逻辑</p>
</li>
<li><p>在 non-blocking ssl 常见 <code>SSL_WANT_*</code> 的提示，表示应用层要等待（或阻塞），等待 SSL 从底层的 socket IO 中读写数据（可能是进行握手，可能是当前 SSL 缓冲区里的数据还不足够进行加解密）。这时应用层可通过 <code>select</code> 来等待读写事件，且在读写事件中，应用层要继续重试上次阻塞的 <code>SSL_read</code> 或 <code>SSL_write</code>。 所以要记录上次是否遇到 <code>SSL_WANT_*</code> 事件，且在当此进行正确的 SSL 读写。具体可见 <a href="http://it-ebooks.info/book/263/" target="_blank" rel="external">《Network Security with OpenSSL》</a> <code>Chapter 5. SSL/TLS Programming</code> 中的 <code>5.2.2.3 Non-blocking I/O</code>，以下的 non-blocking SSL 读写模式，也是来自这部分章节。 </p>
</li>
<li><p>苹果提供了一个简单粗暴的应答 <a href="https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/CommunicatingWIthAPS.html#//apple_ref/doc/uid/TP40008194-CH101-SW3" target="_blank" rel="external">The Feedback Service</a>。经过我抓包发现，苹果发送应答后立即关闭 socket，且 socket 连接不会进入 <code>TIME_WAIT</code> 阶段（苹果发送的最后一个包里包含有<code>FIN, PSH, ACK</code>， 然后应用层在解析到 FIN 包后会回复一个 ACK 包，但这时收到的却是 RST 包）。<br>应用层可能丢失该应答，该应答本来是指向一个无效 token 的，在该无效 token 之后的那些 token 们需要重新发送，而丢失的应答导致无法正确重新发送。 因为应用层在收到应答或知道 socket 被关闭之前，已经发送了 n 个 token， 那个无效的 token 位于 1 ~ n 之间，假设为 m(1&lt;m&lt;n)， 第 m+1 个到 n 的这批 token，将会被苹果丢弃（即 m+1 到 n 的这批 token 将不会收到当次推送）。需要尽可能地减少无效 token 的数量来缓解这个情况。</p>
</li>
<li><p>在上述 2 和 3 的细节下，当 <code>SSL_read</code> 返回 <code>SSL_WANT_*</code> 时，ssl 将可能一直无法得到满足，会陷入一个死循环。因此我放弃当此应答，无法做到 100% 的可靠。 </p>
</li>
<li><p>在发送最后一个 token 后，应检查是否有应答</p>
</li>
</ol>
<h4>一些 sample 如下：  </h4>

<ol>
<li><p>ssl 连接</p>
<pre><code> int do_ssl_connect_blocking(SSL *ssl, int fd)
 {
     int flags, ret;

     SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);

     flags = fcntl(fd, F_GETFL, 0);
     flags &amp;= ~O_NONBLOCK;
     fcntl(fd, F_SETFL, flags);

     ret = SSL_set_fd(ssl, fd);
     if (ret != 1) {
         return -1;
     }

     ret = SSL_connect(ssl);     
     if (ret != 1) {
         return -1;
     }

     return 0;    
 }
</code></pre></li>
<li><p>设置非阻塞</p>
<pre><code> int my_ssl_set_non_blocking(SSL *ssl)
 {
     int fd = SSL_get_fd(ssl);
     if (fd &lt; 0) {
         return -1;
     }

     // remove auto-retry from ssl
     long mode;
     mode = SSL_get_mode(ssl);
     mode &amp;= ~SSL_MODE_AUTO_RETRY;
     SSL_set_mode(ssl, mode);

     // set no-blocking for socket fd
     int flags;
     flags = fcntl(fd, F_GETFL, 0);
     flags |= O_NONBLOCK;
     fcntl(fd, F_SETFL, flags);

     return 0;
 }
</code></pre></li>
<li><p>通过 select 检查可读写</p>
<pre><code> int check_availability(int sockfd, unsigned int *can_read, unsigned int *can_write)
 {
     *can_read = 0;
     *can_write = 0;

     fd_set rset;
     fd_set wset;
     struct timeval timeout = {60, 0};
     int n;

     FD_ZERO(&amp;rset);
     FD_ZERO(&amp;wset);
     FD_SET(sockfd, &amp;rset);
     FD_SET(sockfd, &amp;wset);

     n = select(sockfd+1, &amp;rset, &amp;wset, NULL, &amp;timeout);
     if (n == -1) {
         return -1;
     }
     else if (n) {
         if (FD_ISSET(sockfd, &amp;rset))
             *can_read = 1;
         if (FD_ISSET(sockfd, &amp;wset))
             *can_write = 1;
         return 1;
     }
     else {
         // timeout
         return 0;
     }
 }
</code></pre></li>
<li><p>ssl 读写，消息数据的格式、token 队列的实现，这里就不展开了，替换为<code>... ...</code></p>
<pre><code> int data_transfer(SSL *ssl, int send_cnt)
 {
     // set non-blocking for socket and ssl
     my_ssl_set_non_blocking(ssl);

     int sockfd = SSL_get_fd(ssl);

     // ssl_read
     unsigned int can_read = 0;
     // ssl read retry flag
     unsigned int read_waiton_read = 0;
     unsigned int read_waiton_write = 0;

     // ssl_write
     unsigned int can_write = 0;
     // ssl write retry flag
     unsigned int write_waiton_read = 0;
     unsigned int write_waiton_write = 0;

     // read buffer
     int len_rd = 0;
     char buf_rd[MAX_BUFF_SIZE];
     // write buffer
     int len_wr = 0;
     char buf_wr[MAX_BUFF_SIZE];

     int ret_val = -1;
     int ret, sslerrno;
     int timeout_cnt = 0;
     while (send_cnt &gt;= 0) {
         // get socket I/O event flag: can_read or can_write or both
         ret = check_availability(sockfd, &amp;can_read, &amp;can_write); 
         if (ret &lt; 0) {
             return -1;
         }
         else if (ret == 0) {
             // bad network condition
             timeout_cnt ++;
             if (timeout_cnt &gt;= 3) {
                 goto end;
             }
         }
         else {
             timeout_cnt = 0;
         }

         // ssl read
         // try ssl read first if can both read and write
         //if (!(write_waiton_read || write_waiton_write) 
         //        &amp;&amp; (can_read || (can_write &amp;&amp; read_waiton_read))
         //        &amp;&amp; len_rd &lt; MAX_BUFF_SIZE) 
         if (can_read || (can_write &amp;&amp; read_waiton_read))
         {
             // clear ssl_read retry flag
             read_waiton_read = 0;
             read_waiton_write = 0;

             ret = SSL_read(ssl, buf_rd + len_rd, MAX_BUFF_SIZE - len_rd);
             sslerrno = SSL_get_error(ssl, ret);
             switch (sslerrno) {
                 case SSL_ERROR_NONE:
                     len_rd += ret;
                     if (len_rd &gt;= RSP_MSG_LEN) {
                         // parse and consume RSP_MSG_LEN
                         // ... ...    

                         // get rsp id to reset token queue
                         // ... ...

                         len_rd -= RSP_MSG_LEN;
                     }
                     goto end;
                 case SSL_ERROR_WANT_WRITE:
                     read_waiton_write = 1;
                     goto end;
                 case SSL_ERROR_WANT_READ:
                     read_waiton_read = 1;
                     goto end;
                 case SSL_ERROR_ZERO_RETURN:
                     // connection closed
                     goto end;
                 default:
                     goto end;
             }

         } // ssl read

         // ssl write
         if (!(read_waiton_read || read_waiton_write) 
                 &amp;&amp; (can_write || (can_read &amp;&amp; write_waiton_write))) 
         {
             // clear ssl_write retry flag
             write_waiton_read = 0;
             write_waiton_write = 0;

             if (len_wr == 0) {
                 // get next token from token queue
                 // create push msg, set to buf_wr
                 // ... ... 
             }

             ret = SSL_write(ssl, buf_wr, len_wr);
             sslerrno = SSL_get_error(ssl, ret);
             switch (sslerrno) {
                 /* We wrote something*/
                 case SSL_ERROR_NONE:
                     len_wr -= ret;
                     if (len_wr == 0) {
                         send_cnt --;
                     }
                     else {
                         memmove(buf_wr, buf_wr + ret, len_wr);
                     }
                     break;
                 case SSL_ERROR_WANT_WRITE:
                     write_waiton_write = 1;
                     break;
                 case SSL_ERROR_WANT_READ:
                     write_waiton_read = 1;
                     break;
                 case SSL_ERROR_ZERO_RETURN:
                     //rollback token, resend token
                     // ... ...
                     goto end;
                 default:          
                     //rollback token, resend token
                     // ... ...
                     goto end;
             }

         } // ssl write
     } // while

 end:
     SSL_shutdown(ssl);
     close(sockfd);
     return ret_val;
 }
</code></pre></li>
</ol>
<p>当前的性能上还是不够好，有文档上提到：</p>
<blockquote>
<p>If you’re seeing throughput lower than 9,000 notifications per second, your server might benefit from improved error handling logic.</p>
</blockquote>
<p><br></p>
<ol>
<li><p>文档：<a href="https://developer.apple.com/library/ios/technotes/tn2265/_index.html#//apple_ref/doc/uid/DTS40010376-CH1-TNTAG1" target="_blank" rel="external">Technical Note TN2265 Troubleshooting Push Notifications</a></p>
</li>
<li><p>一个吐槽：<a href="http://redth.codes/the-problem-with-apples-push-notification-ser/" target="_blank" rel="external">The Problem With Apples Push Notification Service… Solutions and Workarounds…</a></p>
</li>
</ol>
<p><br><br>– EOF –</p>

	

	<div>
	    <div>Categories: <a class="category-link" href="/categories/c/">c</a> </div>
	    <div>Tags:<a class="tag-link" href="/tags/c/">c</a>,<a class="tag-link" href="/tags/ios/">ios</a>,<a class="tag-link" href="/tags/openssl/">openssl</a> </div>
	</div>
    </div>

    <hr />
    <footer class="article-footer">
      
        <a href="http://popozhu.github.io/2014/12/27/ios消息推送的优化/#disqus_thread" class="article-comment-link"></a>
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/01/07/wechat-private-api/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-caption">&laquo;</span>
      <span class="article-nav-title">
        
          wechat private api
        
      </span>
    </a>
  
  
    <a href="/2014/11/18/do-not-go-gentle-into-that-good-night/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">Do Not Go Gentle Into That Good Night</span>
      <span class="article-nav-caption">&raquo;</span>
    </a>
  
</nav>


  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>


</section>

	    <footer id="footer">
    <span> <a href="/about"> About </a> </span>
    <span> <a href="/archives"> Misc </a> </span>

    <span>
	<a href="http://hexo.io/" title="Hexo">Hexo</a>
    </span>
    <span>
	&copy; popozhu 2015 
    </span>
</footer>

	</div>

	
<!--
<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js" type="text/javascript"></script>
-->


<script>
  var disqus_shortname = 'popozhu';
  
  var disqus_url = 'http://popozhu.github.io/2014/12/27/ios消息推送的优化/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/script.js" type="text/javascript"></script>

    </body>
</html>
