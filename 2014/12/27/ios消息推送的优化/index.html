<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    

    <title>ios消息推送的优化 | popozhu</title>

    

    <link href="http://fonts.useso.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/css/style.css" type="text/css">

    </head>

    <body>
	<div class="container">
	    <div class="banner">
    <div>
        <span class="site-title"> <a href="/" id="logo">popozhu</a> </span>

        
    </div>

    <div class="banner-right">
        <span class="banner-item"> <a href="/archives"> Misc </a> </span>
        <span class="banner-item"> <a href="/about"> About </a> </span>
    </div>
</div>


	    <section id="main"><article class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
	<header class="article-header">
	    <div class="article-title">
		<div class="title">ios消息推送的优化</div> 
		<small>
		    <time datetime="2014-12-27T15:44:09.000Z" itemprop="datePublished">December 27 2014</time>
		</small>
	    </div>
	</header>
    

    <div class="article-entry" itemprop="articleBody">
	
	    
	    
		<div class="article-toc"> Toc <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">最近有空，做了下优化，主要包括：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">值得一提的事项则有如下： </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">一些 sample 如下：  </span></a></li></ol> </div>
	    

	    <p>去年八月份写过一个 ios 消息批量推送的小程序（<a href="/2013/08/24/ios消息并发推送/">ios消息并发推送</a>)，使用的是 blocking IO， 效率一般，进程还可能长时间 block 在某次 IO 上。</p>
<h4>最近有空，做了下优化，主要包括：</h4>

<ol>
<li>使用 non-blocking IO，也即 non-blocking SSL 读和写，这次主要也是为了实践 SSL non-block 编程</li>
<li>尽可能排除无效 token，推送过程能收到应答，知道哪些是无效 token，在推送后清理这些 token，避免下次推送再遇到</li>
</ol>
<h4>值得一提的事项则有如下： </h4> 

<ol>
<li><p>在我尝试 non-blocking SSL 读写的实践中，建立 socket 连接、建立 ssl 连接，倒还是阻塞的方式，只是在读写推送数据时，才修改为非阻塞模式。因为建立 SSL 连接时会有一个握手过程，非阻塞模式需要中断几次，设置 SSL 让其静默地完成握手，简化逻辑</p>
</li>
<li><p>在 non-blocking ssl 常见 <code>SSL_WANT_*</code> 的提示，表示应用层要等待（或阻塞），等待 SSL 从底层的 socket IO 中读写数据（可能是进行握手，可能是当前 SSL 缓冲区里的数据还不足够进行加解密）。这时应用层可通过 <code>select</code> 来等待读写事件，且在读写事件中，应用层要继续重试上次阻塞的 <code>SSL_read</code> 或 <code>SSL_write</code>。 所以要记录上次是否遇到 <code>SSL_WANT_*</code> 事件，且在当此进行正确的 SSL 读写。具体可见 <a href="http://it-ebooks.info/book/263/" target="_blank" rel="external">《Network Security with OpenSSL》</a> <code>Chapter 5. SSL/TLS Programming</code> 中的 <code>5.2.2.3 Non-blocking I/O</code>，以下的 non-blocking SSL 读写模式，也是来自这部分章节。 </p>
</li>
<li><p>苹果提供了一个简单粗暴的应答 <a href="https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/CommunicatingWIthAPS.html#//apple_ref/doc/uid/TP40008194-CH101-SW3" target="_blank" rel="external">The Feedback Service</a>。经过我抓包发现，苹果发送应答后立即关闭 socket，且 socket 连接不会进入 <code>TIME_WAIT</code> 阶段（苹果发送的最后一个包里包含有<code>FIN, PSH, ACK</code>， 然后应用层在解析到 FIN 包后会回复一个 ACK 包，但这时收到的却是 RST 包）。<br>应用层可能丢失该应答，该应答本来是指向一个无效 token 的，在该无效 token 之后的那些 token 们需要重新发送，而丢失的应答导致无法正确重新发送。 因为应用层在收到应答或知道 socket 被关闭之前，已经发送了 n 个 token， 那个无效的 token 位于 1 ~ n 之间，假设为 m(1&lt;m&lt;n)， 第 m+1 个到 n 的这批 token，将会被苹果丢弃（即 m+1 到 n 的这批 token 将不会收到当次推送）。需要尽可能地减少无效 token 的数量来缓解这个情况。</p>
</li>
<li><p>在上述 2 和 3 的细节下，当 <code>SSL_read</code> 返回 <code>SSL_WANT_*</code> 时，ssl 将可能一直无法得到满足，会陷入一个死循环。因此我放弃当此应答，无法做到 100% 的可靠。 </p>
</li>
<li><p>在发送最后一个 token 后，应检查是否有应答</p>
</li>
</ol>
<h4>一些 sample 如下：  </h4>

<ol>
<li><p>ssl 连接</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">do_ssl_connect_blocking</span><span class="params">(SSL *ssl, <span class="keyword">int</span> fd)</span>
</span>{
    <span class="keyword">int</span> flags, ret;

    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);

    flags = fcntl(fd, F_GETFL, <span class="number">0</span>);
    flags &amp;= ~O_NONBLOCK;
    fcntl(fd, F_SETFL, flags);

    ret = SSL_set_fd(ssl, fd);
    <span class="keyword">if</span> (ret != <span class="number">1</span>) {
        <span class="keyword">return</span> -<span class="number">1</span>;
    }

    ret = SSL_connect(ssl);     
    <span class="keyword">if</span> (ret != <span class="number">1</span>) {
        <span class="keyword">return</span> -<span class="number">1</span>;
    }

    <span class="keyword">return</span> <span class="number">0</span>;    
}
</code></pre></li>
<li><p>设置非阻塞</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">my_ssl_set_non_blocking</span><span class="params">(SSL *ssl)</span>
</span>{
    <span class="keyword">int</span> fd = SSL_get_fd(ssl);
    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {
        <span class="keyword">return</span> -<span class="number">1</span>;
    }

    <span class="comment">// remove auto-retry from ssl</span>
    <span class="keyword">long</span> mode;
    mode = SSL_get_mode(ssl);
    mode &amp;= ~SSL_MODE_AUTO_RETRY;
    SSL_set_mode(ssl, mode);

    <span class="comment">// set no-blocking for socket fd</span>
    <span class="keyword">int</span> flags;
    flags = fcntl(fd, F_GETFL, <span class="number">0</span>);
    flags |= O_NONBLOCK;
    fcntl(fd, F_SETFL, flags);

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre></li>
<li><p>通过 select 检查可读写</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">check_availability</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> *can_read, <span class="keyword">unsigned</span> <span class="keyword">int</span> *can_write)</span>
</span>{
    *can_read = <span class="number">0</span>;
    *can_write = <span class="number">0</span>;

    fd_set rset;
    fd_set wset;
    <span class="keyword">struct</span> timeval timeout = {<span class="number">60</span>, <span class="number">0</span>};
    <span class="keyword">int</span> n;

    FD_ZERO(&amp;rset);
    FD_ZERO(&amp;wset);
    FD_SET(sockfd, &amp;rset);
    FD_SET(sockfd, &amp;wset);

    n = select(sockfd+<span class="number">1</span>, &amp;rset, &amp;wset, <span class="literal">NULL</span>, &amp;timeout);
    <span class="keyword">if</span> (n == -<span class="number">1</span>) {
        <span class="keyword">return</span> -<span class="number">1</span>;
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (n) {
        <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset))
            *can_read = <span class="number">1</span>;
        <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;wset))
            *can_write = <span class="number">1</span>;
        <span class="keyword">return</span> <span class="number">1</span>;
    }
    <span class="keyword">else</span> {
        <span class="comment">// timeout</span>
        <span class="keyword">return</span> <span class="number">0</span>;
    }
}
</code></pre></li>
<li><p>ssl 读写，消息数据的格式、token 队列的实现，这里就不展开了，替换为<code>... ...</code></p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">data_transfer</span><span class="params">(SSL *ssl, <span class="keyword">int</span> send_cnt)</span>
</span>{
    <span class="comment">// set non-blocking for socket and ssl</span>
    my_ssl_set_non_blocking(ssl);

    <span class="keyword">int</span> sockfd = SSL_get_fd(ssl);

    <span class="comment">// ssl_read</span>
    <span class="keyword">unsigned</span> <span class="keyword">int</span> can_read = <span class="number">0</span>;
    <span class="comment">// ssl read retry flag</span>
    <span class="keyword">unsigned</span> <span class="keyword">int</span> read_waiton_read = <span class="number">0</span>;
    <span class="keyword">unsigned</span> <span class="keyword">int</span> read_waiton_write = <span class="number">0</span>;

    <span class="comment">// ssl_write</span>
    <span class="keyword">unsigned</span> <span class="keyword">int</span> can_write = <span class="number">0</span>;
    <span class="comment">// ssl write retry flag</span>
    <span class="keyword">unsigned</span> <span class="keyword">int</span> write_waiton_read = <span class="number">0</span>;
    <span class="keyword">unsigned</span> <span class="keyword">int</span> write_waiton_write = <span class="number">0</span>;

    <span class="comment">// read buffer</span>
    <span class="keyword">int</span> len_rd = <span class="number">0</span>;
    <span class="keyword">char</span> buf_rd[MAX_BUFF_SIZE];
    <span class="comment">// write buffer</span>
    <span class="keyword">int</span> len_wr = <span class="number">0</span>;
    <span class="keyword">char</span> buf_wr[MAX_BUFF_SIZE];

    <span class="keyword">int</span> ret_val = -<span class="number">1</span>;
    <span class="keyword">int</span> ret, sslerrno;
    <span class="keyword">int</span> timeout_cnt = <span class="number">0</span>;
    <span class="keyword">while</span> (send_cnt &gt;= <span class="number">0</span>) {
        <span class="comment">// get socket I/O event flag: can_read or can_write or both</span>
        ret = check_availability(sockfd, &amp;can_read, &amp;can_write); 
        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {
            <span class="keyword">return</span> -<span class="number">1</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) {
            <span class="comment">// bad network condition</span>
            timeout_cnt ++;
            <span class="keyword">if</span> (timeout_cnt &gt;= <span class="number">3</span>) {
                <span class="keyword">goto</span> end;
            }
        }
        <span class="keyword">else</span> {
            timeout_cnt = <span class="number">0</span>;
        }

        <span class="comment">// ssl read</span>
        <span class="comment">// try ssl read first if can both read and write</span>
        <span class="comment">//if (!(write_waiton_read || write_waiton_write) </span>
        <span class="comment">//        &amp;&amp; (can_read || (can_write &amp;&amp; read_waiton_read))</span>
        <span class="comment">//        &amp;&amp; len_rd &lt; MAX_BUFF_SIZE) </span>
        <span class="keyword">if</span> (can_read || (can_write &amp;&amp; read_waiton_read))
        {
            <span class="comment">// clear ssl_read retry flag</span>
            read_waiton_read = <span class="number">0</span>;
            read_waiton_write = <span class="number">0</span>;

            ret = SSL_read(ssl, buf_rd + len_rd, MAX_BUFF_SIZE - len_rd);
            sslerrno = SSL_get_error(ssl, ret);
            <span class="keyword">switch</span> (sslerrno) {
                <span class="keyword">case</span> SSL_ERROR_NONE:
                    len_rd += ret;
                    <span class="keyword">if</span> (len_rd &gt;= RSP_MSG_LEN) {
                        <span class="comment">// parse and consume RSP_MSG_LEN</span>
                        <span class="comment">// ... ...    </span>

                        <span class="comment">// get rsp id to reset token queue</span>
                        <span class="comment">// ... ...</span>

                        len_rd -= RSP_MSG_LEN;
                    }
                    <span class="keyword">goto</span> end;
                <span class="keyword">case</span> SSL_ERROR_WANT_WRITE:
                    read_waiton_write = <span class="number">1</span>;
                    <span class="keyword">goto</span> end;
                <span class="keyword">case</span> SSL_ERROR_WANT_READ:
                    read_waiton_read = <span class="number">1</span>;
                    <span class="keyword">goto</span> end;
                <span class="keyword">case</span> SSL_ERROR_ZERO_RETURN:
                    <span class="comment">// connection closed</span>
                    <span class="keyword">goto</span> end;
                <span class="keyword">default</span>:
                    <span class="keyword">goto</span> end;
            }

        } <span class="comment">// ssl read</span>

        <span class="comment">// ssl write</span>
        <span class="keyword">if</span> (!(read_waiton_read || read_waiton_write) 
                &amp;&amp; (can_write || (can_read &amp;&amp; write_waiton_write))) 
        {
            <span class="comment">// clear ssl_write retry flag</span>
            write_waiton_read = <span class="number">0</span>;
            write_waiton_write = <span class="number">0</span>;

            <span class="keyword">if</span> (len_wr == <span class="number">0</span>) {
                <span class="comment">// get next token from token queue</span>
                <span class="comment">// create push msg, set to buf_wr</span>
                <span class="comment">// ... ... </span>
            }

            ret = SSL_write(ssl, buf_wr, len_wr);
            sslerrno = SSL_get_error(ssl, ret);
            <span class="keyword">switch</span> (sslerrno) {
                <span class="comment">/* We wrote something*/</span>
                <span class="keyword">case</span> SSL_ERROR_NONE:
                    len_wr -= ret;
                    <span class="keyword">if</span> (len_wr == <span class="number">0</span>) {
                        send_cnt --;
                    }
                    <span class="keyword">else</span> {
                        memmove(buf_wr, buf_wr + ret, len_wr);
                    }
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> SSL_ERROR_WANT_WRITE:
                    write_waiton_write = <span class="number">1</span>;
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> SSL_ERROR_WANT_READ:
                    write_waiton_read = <span class="number">1</span>;
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> SSL_ERROR_ZERO_RETURN:
                    <span class="comment">//rollback token, resend token</span>
                    <span class="comment">// ... ...</span>
                    <span class="keyword">goto</span> end;
                <span class="keyword">default</span>:          
                    <span class="comment">//rollback token, resend token</span>
                    <span class="comment">// ... ...</span>
                    <span class="keyword">goto</span> end;
            }

        } <span class="comment">// ssl write</span>
    } <span class="comment">// while</span>

end:
    SSL_shutdown(ssl);
    close(sockfd);
    <span class="keyword">return</span> ret_val;
}
</code></pre></li>
</ol>
<p>当前的性能上还是不够好，有文档上提到：</p>
<blockquote>
<p>If you’re seeing throughput lower than 9,000 notifications per second, your server might benefit from improved error handling logic.</p>
</blockquote>
<p><br></p>
<ol>
<li><p>文档：<a href="https://developer.apple.com/library/ios/technotes/tn2265/_index.html#//apple_ref/doc/uid/DTS40010376-CH1-TNTAG1" target="_blank" rel="external">Technical Note TN2265 Troubleshooting Push Notifications</a></p>
</li>
<li><p>一个吐槽：<a href="http://redth.codes/the-problem-with-apples-push-notification-ser/" target="_blank" rel="external">The Problem With Apples Push Notification Service… Solutions and Workarounds…</a></p>
</li>
</ol>
<p><br><br>– EOF –</p>

	

	<div>
	    <div>Categories: <a class="category-link" href="/categories/c/">c</a> </div>
	    <div>Tags:<a class="tag-link" href="/tags/c/">c</a>,<a class="tag-link" href="/tags/ios/">ios</a>,<a class="tag-link" href="/tags/openssl/">openssl</a> </div>
	</div>
    </div>

    <hr />
    <footer class="article-footer">
      
        <a href="http://popozhu.github.io/2014/12/27/ios消息推送的优化/#disqus_thread" class="article-comment-link"></a>
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/01/07/wechat-private-api/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-caption">&laquo;</span>
      <span class="article-nav-title">
        
          wechat private api
        
      </span>
    </a>
  
  
    <a href="/2014/11/18/do-not-go-gentle-into-that-good-night/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">Do Not Go Gentle Into That Good Night</span>
      <span class="article-nav-caption">&raquo;</span>
    </a>
  
</nav>


  
</article>


<section id="comments">
  <div id="disqus_thread"> </div>
</section>


</section>

	    <footer id="footer">
    popozhu &copy; 2016 
</footer>

	</div>

	
<!--
<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js" type="text/javascript"></script>
-->


<script>
  var disqus_shortname = 'popozhu';
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


<script src="/js/script.js" type="text/javascript"></script>

    </body>
</html>
